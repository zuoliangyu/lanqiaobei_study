C51 COMPILER V9.59.0.0   MAIN                                                              01/25/2024 23:24:51 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Driver) DEBUG OBJECTEXTEND PRI
                    -NT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "main.h"
   2          /* 变量声明区 */
   3          uchar Key_Slow_Down;                 // 按键减速专用变量
   4          uchar Seg_Buf[8] = {10, 10, 10, 10, 10, 10, 10, 10}; // 数码管显示数据存放数组
   5          uchar Seg_Point[8] = {0, 0, 0, 0, 0, 0, 0, 0};     // 数码管小数点数据存放数组
   6          uchar Seg_Pos;                     // 数码管扫描专用变量
   7          uint Seg_Slow_Down;                  // 数码管减速专用变量
   8          uchar ucLed[8] = {0, 0, 0, 0, 0, 0, 0, 0};       // Led显示数据存放数组
   9          
  10          /*时间方面*/
  11          uint time_6s;    // 6s计时
  12          uint time_2s;    // 2s计时
  13          uchar time_100ms;  // 100ms计时
  14          bit reset_flag;    // 复位标志位
  15          bit write_data_flag; // 写入数据标志位
  16          bit led_light_flag;  // 闪烁
  17          
  18          /*显示模式与切换*/
  19          uchar Seg_show_mode;   // 0-测距;1-参数;2-工厂
  20          bit test1_show_mode;   // 0-cm;1-m
  21          bit test2_show_mode;   // 0-距离参数;1-温度参数
  22          uchar test3_show_mode; // 0-校准值 1-传输速度 2-DAC下限
  23          
  24          /*测距相关*/
  25          uint dis_value; // 距离值cm
  26          
  27          /*温度模块*/
  28          float temperature_value; // 温度值
  29          
  30          /*参数界面*/
  31          uchar dis_demo;
  32          uchar temperature_demo;
  33          
  34          /*工厂模式*/
  35          char cali_value;   // 校准值
  36          uint speed_value;  // 传输速度
  37          float dac_low_value; // DAC下限
  38          
  39          /*数据记录与输出*/
  40          float memory_data;
  41          uchar dac_out;
  42          
  43          void init_sys_value()
  44          {
  45   1        Seg_show_mode = 0;
  46   1        test1_show_mode = 0;
  47   1        test2_show_mode = 0;
  48   1        test3_show_mode = 0;
  49   1        dis_demo = 40;
  50   1        temperature_demo = 30;
  51   1        cali_value = 0;
  52   1        speed_value = 340;
  53   1        dac_low_value = 1.0;
  54   1      }
C51 COMPILER V9.59.0.0   MAIN                                                              01/25/2024 23:24:51 PAGE 2   

  55          void init_Seg_LED() // 将数码管和LED清空，避免忘记修改
  56          {
  57   1        uchar i; // 循环变量
  58   1        for (i = 0; i < 8; i++)
  59   1        {
  60   2          Seg_Buf[i] = 10;  // 数码管显示内容初始化
  61   2          Seg_Point[i] = 0; // 数码管小数点初始化
  62   2          ucLed[i] = 0;   // LED显示内容初始化
  63   2        }
  64   1      }
  65          /* 键盘处理函数 */
  66          void Key_Proc()
  67          {
  68   1        static uchar Key_Val, Key_Down, Key_Old, Key_Up; // 按键专用变量
  69   1        if (Key_Slow_Down)
  70   1          return;
  71   1        Key_Slow_Down = 1; // 键盘减速程序
  72   1      
  73   1        Key_Val = Key_Read();           // 实时读取键码值
  74   1        Key_Down = Key_Val & (Key_Old ^ Key_Val); // 捕捉按键下降沿
  75   1        Key_Up = ~Key_Val & (Key_Old ^ Key_Val);  // 捕捉按键上降沿
  76   1        Key_Old = Key_Val;              // 辅助扫描变量
  77   1      
  78   1        // 当我们没有进行记录
  79   1        if (!write_data_flag)
  80   1        {
  81   2          switch (Key_Down)
  82   2          {
  83   3          case 4:
  84   3            init_Seg_LED();
  85   3            Seg_show_mode = (++Seg_show_mode < 3) ? Seg_show_mode : 0;
  86   3            test1_show_mode = test2_show_mode = test3_show_mode = 0;
  87   3            break;
  88   3          case 5:
  89   3            init_Seg_LED();
  90   3            switch (Seg_show_mode)
  91   3            {
  92   4            case 0:
  93   4              test1_show_mode = ~test1_show_mode;
  94   4              break;
  95   4            case 1:
  96   4              test2_show_mode = ~test2_show_mode;
  97   4              break;
  98   4            case 2:
  99   4              test3_show_mode = (++test3_show_mode < 3) ? test3_show_mode : 0;
 100   4              break;
 101   4            }
 102   3            break;
 103   3          case 8:
 104   3            switch (Seg_show_mode)
 105   3            {
 106   4            case 0:
 107   4              write_data_flag = 1;
 108   4              break;
 109   4            case 1:
 110   4              if (test2_show_mode)
 111   4                temperature_demo = (++temperature_demo < 80) ? temperature_demo : 80;
 112   4              else
 113   4                dis_demo = (dis_demo + 10 < 90) ? dis_demo + 10 : 90;
 114   4              break;
 115   4            case 2:
 116   4              switch (test3_show_mode)
C51 COMPILER V9.59.0.0   MAIN                                                              01/25/2024 23:24:51 PAGE 3   

 117   4              {
 118   5              case 0:
 119   5                cali_value = (cali_value + 5 < 90) ? cali_value + 5 : 90;
 120   5                break;
 121   5              case 1:
 122   5                speed_value = (speed_value + 10 < 9990) ? speed_value + 10 : 9990;
 123   5                break;
 124   5              case 2:
 125   5                dac_low_value = (dac_low_value + 0.1 < 2.0) ? dac_low_value + 0.1 : 2.0;
 126   5                break;
 127   5              }
 128   4              break;
 129   4            }
 130   3            break;
 131   3          case 9:
 132   3            switch (Seg_show_mode)
 133   3            {
 134   4            case 0:
 135   4              // 开始输出数据
 136   4              if (memory_data > 90)
 137   4              {
 138   5                dac_out = 5;
 139   5              }
 140   4              else if (memory_data == 0)
 141   4              {
 142   5                dac_out = 0;
 143   5              }
 144   4              else
 145   4              {
 146   5                dac_out = (5 - dac_low_value) / 80 * (memory_data - 10) + dac_low_value;
 147   5              }
 148   4              Da_Write(dac_out);
 149   4              break;
 150   4            case 1:
 151   4              if (test2_show_mode)
 152   4                temperature_demo = (--temperature_demo > 0) ? temperature_demo : 0;
 153   4              else
 154   4                dis_demo = (dis_demo - 10 > 10) ? dis_demo - 10 : 10;
 155   4              break;
 156   4            case 2:
 157   4              switch (test3_show_mode)
 158   4              {
 159   5              case 0:
 160   5                cali_value = (cali_value - 5 > -90) ? cali_value - 5 : -90;
 161   5                break;
 162   5              case 1:
 163   5                speed_value = (speed_value - 10 > 10) ? speed_value - 10 : 10;
 164   5                break;
 165   5              case 2:
 166   5                dac_low_value = (dac_low_value - 0.1 > 0.1) ? dac_low_value - 0.1 : 0.1;
 167   5                break;
 168   5              }
 169   4              break;
 170   4            }
 171   3            break;
 172   3          }
 173   2          // 如果同时按下89
 174   2          if (Key_Old == 89)
 175   2          {
 176   3            reset_flag = 1;
 177   3          }
 178   2          else
C51 COMPILER V9.59.0.0   MAIN                                                              01/25/2024 23:24:51 PAGE 4   

 179   2          {
 180   3            reset_flag = 0;
 181   3          }
 182   2        }
 183   1      }
 184          
 185          /* 信息处理函数 */
 186          void Seg_Proc()
 187          {
 188   1        uint int_temperature_value; // 温度值整型变量
 189   1        uchar i;
 190   1        uchar temp_DAC_low;
 191   1        int temp_cali;
 192   1        if (Seg_Slow_Down)
 193   1          return;
 194   1        Seg_Slow_Down = 1; // 数码管减速程序
 195   1        switch (Seg_show_mode)
 196   1        {
 197   2        case 0:
 198   2          /* 测距界面 */
 199   2          temperature_value = rd_temperature();
 200   2          int_temperature_value = temperature_value * 10;
 201   2          Seg_Buf[0] = int_temperature_value / 100;
 202   2          Seg_Buf[1] = int_temperature_value % 100 / 10;
 203   2          Seg_Buf[2] = int_temperature_value % 10;
 204   2          Seg_Point[1] = 1; // 小数点
 205   2          Seg_Buf[3] = 13;  //-
 206   2          dis_value = (uint)Ut_Wave_Data(speed_value, cali_value);
 207   2          // 显示单位为m
 208   2          if (test1_show_mode)
 209   2          {
 210   3            Seg_Buf[4] = (dis_value / 1000) ? dis_value / 1000 : 10;
 211   3            Seg_Buf[5] = dis_value / 100 % 10;
 212   3            Seg_Buf[6] = dis_value / 10 % 10;
 213   3            Seg_Buf[7] = dis_value % 10;
 214   3            Seg_Point[5] = 1;
 215   3          }
 216   2          // 显示单位为cm
 217   2          else
 218   2          {
 219   3            Seg_Buf[4] = dis_value / 1000;
 220   3            Seg_Buf[5] = dis_value / 100 % 10;
 221   3            Seg_Buf[6] = dis_value / 10 % 10;
 222   3            Seg_Buf[7] = dis_value % 10;
 223   3            i = 4;
 224   3            while (Seg_Buf[i] == 0)
 225   3            {
 226   4              if (i == 7)
 227   4                break;
 228   4              Seg_Buf[i] = 10;
 229   4              i++;
 230   4            }
 231   3          }
 232   2          break;
 233   2        case 1:
 234   2          /*参数界面*/
 235   2          Seg_Buf[0] = 11; // P
 236   2          Seg_Buf[1] = (uchar)test2_show_mode + 1;
 237   2          Seg_Buf[2] = Seg_Buf[3] = Seg_Buf[4] = Seg_Buf[5] = 10; // 灭
 238   2          Seg_Buf[6] = test2_show_mode ? temperature_demo / 10 : dis_demo / 10;
 239   2          Seg_Buf[7] = test2_show_mode ? temperature_demo % 10 : dis_demo % 10;
 240   2          break;
C51 COMPILER V9.59.0.0   MAIN                                                              01/25/2024 23:24:51 PAGE 5   

 241   2        case 2:
 242   2          /*工厂界面*/
 243   2          Seg_Buf[0] = 12; // F
 244   2          Seg_Buf[1] = test3_show_mode + 1;
 245   2          Seg_Buf[2] = Seg_Buf[3] = 10; // 灭
 246   2          switch (test3_show_mode)
 247   2          {
 248   3          case 0:
 249   3            Seg_Buf[4] = 10;
 250   3            /* 显示校准值 */
 251   3            temp_cali = abs((int)cali_value);
 252   3            Seg_Buf[5] = temp_cali / 100;
 253   3            Seg_Buf[6] = temp_cali / 10 % 10;
 254   3            Seg_Buf[7] = temp_cali % 10;
 255   3            i = 5;
 256   3            while (Seg_Buf[i] == 0)
 257   3            {
 258   4              if (i == 7)
 259   4                break;
 260   4              Seg_Buf[i] = 10;
 261   4              i++;
 262   4            }
 263   3            if (cali_value < 0)
 264   3            {
 265   4              Seg_Buf[i - 1] = 13; //-
 266   4            }
 267   3            break;
 268   3          case 1:
 269   3            /* 显示传输速度 */
 270   3            Seg_Buf[4] = speed_value / 1000;
 271   3            Seg_Buf[5] = speed_value / 100 % 10;
 272   3            Seg_Buf[6] = speed_value / 10 % 10;
 273   3            Seg_Buf[7] = speed_value % 10;
 274   3            i = 4;
 275   3            while (Seg_Buf[i] == 0)
 276   3            {
 277   4              if (i == 7)
 278   4                break;
 279   4              Seg_Buf[i] = 10;
 280   4              i++;
 281   4            }
 282   3            break;
 283   3          case 2:
 284   3      
 285   3            temp_DAC_low = dac_low_value * 10;
 286   3            /* 显示DAC下限 */
 287   3            Seg_Buf[4] = Seg_Buf[5] = 10;
 288   3            Seg_Buf[6] = temp_DAC_low / 10;
 289   3            Seg_Buf[7] = temp_DAC_low % 10;
 290   3            Seg_Point[6] = 1;
 291   3            break;
 292   3          }
 293   2          break;
 294   2        }
 295   1      }
 296          
 297          /* 其他显示函数 */
 298          void Led_Proc()
 299          {
 300   1        uchar i;
 301   1        switch (Seg_show_mode)
 302   1        {
C51 COMPILER V9.59.0.0   MAIN                                                              01/25/2024 23:24:51 PAGE 6   

 303   2        case 0:
 304   2          for (i = 0; i < 8; i++)
 305   2          {
 306   3            ucLed[i] = dis_value & (0x01 << i);
 307   3          }
 308   2          if (dis_value >= 255)
 309   2          {
 310   3            ucLed[0] = ucLed[1] = ucLed[2] = ucLed[3] = ucLed[4] = ucLed[5] = ucLed[6] = ucLed[7] = 1;
 311   3          }
 312   2          break;
 313   2        case 1:
 314   2          ucLed[7] = 1;
 315   2          break;
 316   2        case 2:
 317   2          ucLed[0] = led_light_flag;
 318   2          break;
 319   2        }
 320   1        if ((dis_demo + 5 >= dis_value) && (temperature_demo >= temperature_value))
 321   1        {
 322   2          Relay(1);
 323   2        }
 324   1        else
 325   1        {
 326   2          Relay(0);
 327   2        }
 328   1      }
 329          
 330          /* 定时器0中断初始化函数 */
 331          void Timer0Init(void) // 1毫秒@12.000MHz
 332          {
 333   1        AUXR &= 0x7F; // 定时器时钟12T模式
 334   1        TMOD &= 0xF0; // 设置定时器模式
 335   1        TL0 = 0x18;   // 设置定时初始值
 336   1        TH0 = 0xFC;   // 设置定时初始值
 337   1        TF0 = 0;    // 清除TF0标志
 338   1        TR0 = 1;    // 定时器0开始计时
 339   1        ET0 = 1;    // 定时器中断0打开
 340   1        EA = 1;     // 总中断打开
 341   1      }
 342          
 343          /* 定时器0中断服务函数 */
 344          void Timer0Server() interrupt 1
 345          {
 346   1        if (++Key_Slow_Down == 10)
 347   1          Key_Slow_Down = 0; // 键盘减速专用
 348   1        if (++Seg_Slow_Down == 500)
 349   1          Seg_Slow_Down = 0; // 数码管减速专用
 350   1        if (++Seg_Pos == 8)
 351   1          Seg_Pos = 0; // 数码管显示专用
 352   1        if (reset_flag)
 353   1        {
 354   2          if (++time_2s >= 2000)
 355   2          {
 356   3            time_2s = 0;
 357   3            init_sys_value();
 358   3          }
 359   2        }
 360   1        if (write_data_flag)
 361   1        {
 362   2          memory_data = dis_value;
 363   2          if (++time_6s >= 6000)
 364   2          {
C51 COMPILER V9.59.0.0   MAIN                                                              01/25/2024 23:24:51 PAGE 7   

 365   3            time_6s = write_data_flag = 0;
 366   3          }
 367   2        }
 368   1        if (++time_100ms >= 100)
 369   1        {
 370   2          led_light_flag = ~led_light_flag;
 371   2          time_100ms = 0;
 372   2        }
 373   1        Seg_Disp(Seg_Pos, Seg_Buf[Seg_Pos], Seg_Point[Seg_Pos]);
 374   1        Led_Disp(Seg_Pos, ucLed[Seg_Pos]);
 375   1      }
 376          
 377          void Delay750ms() //@12MHz
 378          {
 379   1        unsigned char i, j, k;
 380   1      
 381   1        _nop_();
 382   1        _nop_();
 383   1        i = 35;
 384   1        j = 51;
 385   1        k = 182;
 386   1        do
 387   1        {
 388   2          do
 389   2          {
 390   3            while (--k)
 391   3              ;
 392   3          } while (--j);
 393   2        } while (--i);
 394   1      }
 395          
 396          /* Main */
 397          void main()
 398          {
 399   1        init_sys_value(); // 初始化所有数据
 400   1        // 如果有温度读取的话
 401   1        rd_temperature();
 402   1        Delay750ms();
 403   1      
 404   1        System_Init();
 405   1        Timer0Init();
 406   1        while (1)
 407   1        {
 408   2          Key_Proc();
 409   2          Seg_Proc();
 410   2          Led_Proc();
 411   2        }
 412   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1906    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     59       1
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      5    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
