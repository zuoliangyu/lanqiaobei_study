C51 COMPILER V9.59.0.0   MAIN                                                              02/16/2024 23:02:23 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Driver) DEBUG OBJECTEXTEND PRI
                    -NT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "main.h"
   2          /* 变量声明区 */
   3          uchar Key_Slow_Down;                 // 按键减速专用变量
   4          uchar Seg_Buf[8] = {10, 10, 10, 10, 10, 10, 10, 10}; // 数码管显示数据存放数组
   5          uchar Seg_Point[8] = {0, 0, 0, 0, 0, 0, 0, 0};     // 数码管小数点数据存放数组
   6          uchar Seg_Pos;                     // 数码管扫描专用变量
   7          uint Seg_Slow_Down;                  // 数码管减速专用变量
   8          uchar ucLed[8] = {0, 0, 0, 0, 0, 0, 0, 0};       // Led显示数据存放数组
   9          
  10          /* 显示 */
  11          uchar Seg_Show_mode;  // 0 测距 1 参数 2 工厂
  12          uchar dis_show_mode;  // 0 cm 1 m
  13          uchar para_show_mode; // 0 距离 1 温度
  14          uchar fac_show_mode;  // 0 校准值 1 介质 2 DAC输出
  15          
  16          /* 数据 */
  17          uint temperature_data_10x; // 10倍的温度值
  18          uint distance_data;      // 距离值 存储的时候，单位为cm
  19          uint write_distance_data;  // 记录距离值 存储的时候，单位为cm
  20          uchar para_temperature;    // 温度参数
  21          uchar para_distance;     // 距离参数
  22          uchar dac_output_data;     // DAC输出值
  23          
  24          char calibration_value;   // 校准值
  25          uint transmission_speed;  // 传输速度
  26          uchar dac_low_output_10x; // DAC输出下限*10
  27          
  28          /* 判断 */
  29          bit write_distance_data_flag; // 距离写入标志
  30          bit reset_flag;         // 复位标志
  31          bit led_show_flag;        // Led显示标志
  32          /* 时间 */
  33          uint time_6s;
  34          uint time_2s;
  35          uchar time_100ms;
  36          void set_Seg_init(uchar start, uchar end)
  37          {
  38   1        uchar i;
  39   1        for (i = start; i < end; i++)
  40   1        {
  41   2          Seg_Buf[i] = 10;
  42   2          Seg_Point[i] = 0;
  43   2        }
  44   1      }
  45          void reset_data()
  46          {
  47   1        Seg_Show_mode = 0;
  48   1        dis_show_mode = 0;
  49   1        para_distance = 40;
  50   1        para_temperature = 30;
  51   1        calibration_value = 0;
  52   1        transmission_speed = 340;
  53   1        dac_low_output_10x = 10;
  54   1      }
C51 COMPILER V9.59.0.0   MAIN                                                              02/16/2024 23:02:23 PAGE 2   

  55          /* 键盘处理函数 */
  56          void Key_Proc()
  57          {
  58   1        static uchar Key_Val, Key_Down, Key_Old, Key_Up; // 按键专用变量
  59   1        float temp_V;
  60   1        if (Key_Slow_Down)
  61   1          return;
  62   1        Key_Slow_Down = 1; // 键盘减速程序
  63   1      
  64   1        Key_Val = Key_Read();           // 实时读取键码值
  65   1        Key_Down = Key_Val & (Key_Old ^ Key_Val); // 捕捉按键下降沿
  66   1        Key_Up = ~Key_Val & (Key_Old ^ Key_Val);  // 捕捉按键上降沿
  67   1        Key_Old = Key_Val;              // 辅助扫描变量
  68   1        // 没有进行写入，全部按键有效
  69   1        if (!write_distance_data_flag)
  70   1        {
  71   2          if (Key_Down == 4)
  72   2          {
  73   3            Seg_Show_mode = (++Seg_Show_mode) % 3;
  74   3            set_Seg_init(0, 8);
  75   3            dis_show_mode = para_show_mode = fac_show_mode = 0;
  76   3          }
  77   2          if (Key_Down == 5)
  78   2          {
  79   3            switch (Seg_Show_mode)
  80   3            {
  81   4            case 0:
  82   4              dis_show_mode = (++dis_show_mode) % 2;
  83   4              set_Seg_init(4, 8);
  84   4              break;
  85   4      
  86   4            case 1:
  87   4              para_show_mode = (++para_show_mode) % 2;
  88   4              break;
  89   4            case 2:
  90   4              fac_show_mode = (++fac_show_mode) % 3;
  91   4              set_Seg_init(2, 8);
  92   4              break;
  93   4            }
  94   3          }
  95   2          switch (Seg_Show_mode)
  96   2          {
  97   3          case 0:
  98   3            /* 测距界面 */
  99   3            if (Key_Down == 8)
 100   3            {
 101   4              write_distance_data = distance_data;
 102   4              write_distance_data_flag = 1;
 103   4            }
 104   3            else if (Key_Down == 9 && write_distance_data != 0)
 105   3            {
 106   4              if (write_distance_data < 10)
 107   4              {
 108   5                dac_output_data = dac_low_output_10x * 51 / 10;
 109   5              }
 110   4              else if (write_distance_data > 90)
 111   4              {
 112   5                dac_output_data = 255;
 113   5              }
 114   4              else
 115   4              {
 116   5                temp_V = (5 - dac_low_output_10x / 10.0) * (write_distance_data - 90) / 80 + 5;
C51 COMPILER V9.59.0.0   MAIN                                                              02/16/2024 23:02:23 PAGE 3   

 117   5                dac_output_data = temp_V * 51;
 118   5              }
 119   4              Da_Write(dac_output_data); // 在我们没有进行数据记录的时候，输出的一直是0
 120   4            }
 121   3            break;
 122   3      
 123   3          case 1:
 124   3            /* 参数界面 */
 125   3            if (Key_Down == 8)
 126   3            {
 127   4              switch (para_show_mode)
 128   4              {
 129   5              case 0:
 130   5                para_distance = (para_distance + 10 == 90) ? 90 : para_distance + 10;
 131   5                break;
 132   5              case 1:
 133   5                para_temperature = (++para_temperature == 90) ? 90 : para_temperature;
 134   5                break;
 135   5              }
 136   4            }
 137   3            else if (Key_Down == 9)
 138   3            {
 139   4      
 140   4              switch (para_show_mode)
 141   4              {
 142   5              case 0:
 143   5                para_distance = (para_distance - 10 == 10) ? 10 : para_distance - 10;
 144   5                break;
 145   5              case 1:
 146   5                para_temperature = (--para_temperature == 0) ? 0 : para_temperature;
 147   5                break;
 148   5              }
 149   4            }
 150   3            break;
 151   3      
 152   3          case 2:
 153   3            /* 工厂模式 */
 154   3            if (Key_Down == 8)
 155   3            {
 156   4              switch (fac_show_mode)
 157   4              {
 158   5              case 0:
 159   5                calibration_value = (calibration_value + 5 == 90) ? 90 : calibration_value + 5;
 160   5                break;
 161   5              case 1:
 162   5                transmission_speed = (transmission_speed + 10 == 9990) ? 9990 : transmission_speed + 10;
 163   5                break;
 164   5              case 2:
 165   5                dac_low_output_10x = (++dac_low_output_10x == 90) ? 20 : dac_low_output_10x;
 166   5                break;
 167   5              }
 168   4            }
 169   3            else if (Key_Down == 9)
 170   3            {
 171   4              switch (fac_show_mode)
 172   4              {
 173   5              case 0:
 174   5                calibration_value = (calibration_value - 5 == -90) ? -90 : calibration_value - 5;
 175   5                break;
 176   5              case 1:
 177   5                transmission_speed = (transmission_speed - 10 == 10) ? 10 : transmission_speed - 10;
 178   5                break;
C51 COMPILER V9.59.0.0   MAIN                                                              02/16/2024 23:02:23 PAGE 4   

 179   5              case 2:
 180   5                dac_low_output_10x = (--dac_low_output_10x == 1) ? 1 : dac_low_output_10x;
 181   5                break;
 182   5              }
 183   4            }
 184   3            break;
 185   3          }
 186   2          reset_flag = (Key_Down == 89);
 187   2        }
 188   1      }
 189          
 190          /* 信息处理函数 */
 191          void Seg_Proc()
 192          {
 193   1        if (Seg_Slow_Down)
 194   1          return;
 195   1        Seg_Slow_Down = 1; // 数码管减速程序
 196   1        switch (Seg_Show_mode)
 197   1        {
 198   2        case 0:
 199   2          temperature_data_10x = rd_temperature() * 10;
 200   2          Seg_Buf[0] = temperature_data_10x / 100 % 10;
 201   2          Seg_Buf[1] = temperature_data_10x / 10 % 10;
 202   2          Seg_Buf[2] = temperature_data_10x % 10;
 203   2          Seg_Point[1] = 1;
 204   2          Seg_Buf[3] = 11; // -
 205   2          distance_data = Ut_Wave_Data(calibration_value, transmission_speed);
 206   2          /* 测距界面 */
 207   2          switch (dis_show_mode)
 208   2          {
 209   3          case 0:
 210   3            /* cm */
 211   3            Seg_Buf[4] = (distance_data / 1000 % 10 == 0) ? 10 : distance_data / 1000 % 10;
 212   3            Seg_Buf[5] = ((distance_data / 100 % 10 == 0) && (Seg_Buf[4] == 10)) ? 10 : distance_data / 100 % 10;
 213   3            Seg_Buf[6] = ((distance_data / 10 % 10 == 0) && (Seg_Buf[5] == 10)) ? 10 : distance_data / 10 % 10;
 214   3            Seg_Buf[7] = distance_data % 10;
 215   3            break;
 216   3          case 1:
 217   3            /* m */
 218   3            Seg_Buf[4] = (distance_data / 1000 % 10 == 0) ? 10 : distance_data / 1000 % 10;
 219   3            Seg_Buf[5] = distance_data / 100 % 10;
 220   3            Seg_Buf[6] = distance_data / 10 % 10;
 221   3            Seg_Buf[7] = distance_data % 10;
 222   3            Seg_Point[5] = 1;
 223   3            break;
 224   3          }
 225   2          break;
 226   2      
 227   2        case 1:
 228   2          /* 参数界面 */
 229   2          Seg_Buf[0] = 12; // P
 230   2          Seg_Buf[1] = para_show_mode + 1;
 231   2          switch (para_show_mode)
 232   2          {
 233   3          case 0:
 234   3            /* 距离 */
 235   3            Seg_Buf[6] = para_distance / 10 % 10;
 236   3            Seg_Buf[7] = para_distance % 10;
 237   3            break;
 238   3          case 1:
 239   3            /* 温度 */
 240   3            Seg_Buf[6] = para_temperature / 10 % 10;
C51 COMPILER V9.59.0.0   MAIN                                                              02/16/2024 23:02:23 PAGE 5   

 241   3            Seg_Buf[7] = para_temperature % 10;
 242   3            break;
 243   3          }
 244   2          break;
 245   2      
 246   2        case 2:
 247   2          /* 工厂模式 */
 248   2          Seg_Buf[0] = 13; // F
 249   2          Seg_Buf[1] = fac_show_mode + 1;
 250   2          switch (para_show_mode)
 251   2          {
 252   3          case 0:
 253   3            /* 校准值 */
 254   3            if (calibration_value <= -10)
 255   3            {
 256   4              Seg_Buf[5] = 11; //-
 257   4              Seg_Buf[6] = (-calibration_value) / 10 % 10;
 258   4              Seg_Buf[7] = (-calibration_value) % 10;
 259   4            }
 260   3            else if (calibration_value < 0)
 261   3            {
 262   4              Seg_Buf[5] = 10;
 263   4              Seg_Buf[6] = 11; //-
 264   4              Seg_Buf[7] = (-calibration_value) % 10;
 265   4            }
 266   3            else
 267   3            {
 268   4              Seg_Buf[5] = 10;
 269   4              Seg_Buf[6] = calibration_value / 10 % 10;
 270   4              Seg_Buf[7] = calibration_value % 10;
 271   4            }
 272   3            break;
 273   3          case 1:
 274   3            /* 介质 */
 275   3            Seg_Buf[4] = (transmission_speed / 1000 % 10 == 0) ? 10 : transmission_speed / 1000 % 10;
 276   3            Seg_Buf[5] = ((transmission_speed / 100 % 10 == 0) && Seg_Buf[4] == 10) ? 10 : transmission_speed / 100
             - % 10;
 277   3            Seg_Buf[6] = transmission_speed / 10 % 10;
 278   3            Seg_Buf[7] = transmission_speed % 10;
 279   3      
 280   3            break;
 281   3          case 2:
 282   3            /* DAC输出 */
 283   3            Seg_Buf[6] = dac_low_output_10x / 10 % 10;
 284   3            Seg_Buf[7] = dac_low_output_10x % 10;
 285   3            Seg_Point[6] = 1;
 286   3            break;
 287   3          }
 288   2          break;
 289   2        }
 290   1      }
 291          
 292          /* 其他显示函数 */
 293          void Led_Proc()
 294          {
 295   1        uchar i;
 296   1        switch (Seg_Show_mode)
 297   1        {
 298   2        case 0:
 299   2          /* 测距 */
 300   2          if (distance_data > 255)
 301   2          {
C51 COMPILER V9.59.0.0   MAIN                                                              02/16/2024 23:02:23 PAGE 6   

 302   3            for (i = 0; i < 8; i++)
 303   3            {
 304   4              ucLed[i] = 1;
 305   4            }
 306   3          }
 307   2          else
 308   2          {
 309   3            for (i = 0; i < 8; i++)
 310   3            {
 311   4              ucLed[i] = distance_data & (1 << i);
 312   4            }
 313   3          }
 314   2          break;
 315   2        case 1:
 316   2          /* 参数 */
 317   2          for (i = 0; i < 7; i++)
 318   2            ucLed[i] = 0;
 319   2          ucLed[7] = 1;
 320   2          break;
 321   2        case 2:
 322   2          /* 工厂 */
 323   2          for (i = 1; i < 8; i++)
 324   2            ucLed[i] = 0;
 325   2          ucLed[0] = led_show_flag;
 326   2          break;
 327   2        }
 328   1        Relay(((para_distance - 5 <= distance_data) &&
 329   1             (distance_data <= para_distance + 5) &&
 330   1             (temperature_data_10x / 10.0 <= para_temperature)));
 331   1      }
 332          
 333          /* 定时器0中断初始化函数 */
 334          void Timer0Init(void) // 1毫秒@12.000MHz
 335          {
 336   1        AUXR &= 0x7F; // 定时器时钟12T模式
 337   1        TMOD &= 0xF0; // 设置定时器模式
 338   1        TL0 = 0x18;   // 设置定时初始值
 339   1        TH0 = 0xFC;   // 设置定时初始值
 340   1        TF0 = 0;    // 清除TF0标志
 341   1        TR0 = 1;    // 定时器0开始计时
 342   1        ET0 = 1;    // 定时器中断0打开
 343   1        EA = 1;     // 总中断打开
 344   1      }
 345          
 346          /* 定时器0中断服务函数 */
 347          void Timer0Server() interrupt 1
 348          {
 349   1        if (++Key_Slow_Down == 10)
 350   1          Key_Slow_Down = 0; // 键盘减速专用
 351   1        if (++Seg_Slow_Down == 500)
 352   1          Seg_Slow_Down = 0; // 数码管减速专用
 353   1        if (++Seg_Pos == 8)
 354   1          Seg_Pos = 0; // 数码管显示专用
 355   1        if (write_distance_data_flag)
 356   1        {
 357   2          if (++time_6s == 6000)
 358   2          {
 359   3            time_6s = 0;
 360   3            write_distance_data_flag = 0;
 361   3          }
 362   2        }
 363   1        // 开始复位按键计时
C51 COMPILER V9.59.0.0   MAIN                                                              02/16/2024 23:02:23 PAGE 7   

 364   1        if (reset_flag)
 365   1        {
 366   2          if (++time_2s >= 2000)
 367   2          {
 368   3            time_2s = 0;
 369   3            reset_data();
 370   3          }
 371   2        }
 372   1        else
 373   1          time_2s = 0;
 374   1        // 100ms闪烁一下
 375   1        if (++time_100ms == 100)
 376   1        {
 377   2          time_100ms = 0;
 378   2          led_show_flag ^= 1;
 379   2        }
 380   1        Seg_Disp(Seg_Pos, Seg_Buf[Seg_Pos], Seg_Point[Seg_Pos]);
 381   1        Led_Disp(Seg_Pos, ucLed[Seg_Pos]);
 382   1      }
 383          
 384          void Delay750ms() //@12MHz
 385          {
 386   1        unsigned char i, j, k;
 387   1      
 388   1        _nop_();
 389   1        _nop_();
 390   1        i = 35;
 391   1        j = 51;
 392   1        k = 182;
 393   1        do
 394   1        {
 395   2          do
 396   2          {
 397   3            while (--k)
 398   3              ;
 399   3          } while (--j);
 400   2        } while (--i);
 401   1      }
 402          
 403          /* Main */
 404          void main()
 405          {
 406   1      
 407   1        System_Init();
 408   1        Timer0Init();
 409   1        reset_data();
 410   1        // 如果有温度读取的话
 411   1        rd_temperature();
 412   1        Delay750ms();
 413   1        while (1)
 414   1        {
 415   2          Key_Proc();
 416   2          Seg_Proc();
 417   2          Led_Proc();
 418   2        }
 419   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1920    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
C51 COMPILER V9.59.0.0   MAIN                                                              02/16/2024 23:02:23 PAGE 8   

   PDATA SIZE       =   ----    ----
   DATA SIZE        =     54       5
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      3    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
