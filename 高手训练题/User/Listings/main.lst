C51 COMPILER V9.59.0.0   MAIN                                                              01/27/2024 10:56:40 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Driver) DEBUG OBJECTEXTEND PRI
                    -NT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /* å¤´æ–‡ä»¶å£°æ˜åŒº */
   2          #include "main.h"
   3          
   4          /* å˜é‡å£°æ˜åŒº */
   5          
   6          uchar Key_Slow_Down;                      // æŒ‰é”®å‡é€Ÿä¸“ç”¨å˜é‡
   7          uint Uart_Slow_Down;                      // æŒ‰é”®å‡é€Ÿä¸“ç”¨å˜é‡
   8          idata uchar Seg_Buf[8] = {10, 10, 10, 10, 10, 10, 10, 10};    // æ•°ç ç®¡æ˜¾ç¤ºæ•°æ®å­˜æ”¾æ•°ç»„
   9          idata uchar Seg_Point[8] = {0, 0, 0, 0, 0, 0, 0, 0};      // æ•°ç ç®¡å°æ•°ç‚¹æ•°æ®å­˜æ”¾æ•°ç»„
  10          uchar Seg_Pos;                          // æ•°ç ç®¡æ‰«æä¸“ç”¨å˜é‡
  11          uint Seg_Slow_Down;                       // æ•°ç ç®¡å‡é€Ÿä¸“ç”¨å˜é‡
  12          idata uchar ucLed[8] = {0, 0, 0, 0, 0, 0, 0, 0};        // Ledæ˜¾ç¤ºæ•°æ®å­˜æ”¾æ•°ç»„
  13          uchar Seg_Disp_Mode;                      // æ¨¡å¼ç•Œé¢ 0-ç³»ç»Ÿåˆå§‹ç•Œé¢ 1-ä¸»ç•Œé¢ æ—¶é’Ÿ  ä¿¡æ¯
  14          uchar Pass_Word[8] = {1, 2, 3, 4, 5, 6, 7, 8};          // åˆå§‹å¯†ç 
  15          idata uchar Pass_Input[8] = {11, 11, 11, 11, 11, 11, 11, 11}; // å¯†ç è¾“å…¥
  16          uchar Pass_Input_Index;                     // å¯†ç è¾“å…¥æŒ‡é’ˆ
  17          uint Timer_3000Ms;                        // é•¿æŒ‰è®¡æ—¶
  18          bit Key_Flag;                         // è®¡æ—¶æ ‡å¿—ä½
  19          idata uchar Clock_Crl[3] = {23, 59, 55};            // æ—¶é’Ÿ
  20          uint Timer_500Ms;                       // æ—¶é’Ÿé—´éš”ç¬¦é—ªçƒ
  21          bit Seg_Star_Flag;                        // é—ªçƒæ ‡å¿—ä½
  22          uchar ultrasonic;                       // è¶…å£°æ³¢æµ‹è·
  23          uchar ultrasonic_Ture;                      // è¶…å£°æ³¢æµ‹è·
  24          float AD_Output;                        // ADè¾“å‡º
  25          float Temp;                           // æ¸©åº¦
  26          bit Sun_Flag;                         // æ˜¯å¦æœ‰å…‰æ ‡å¿—ä½
  27          uint Timer_2000Ms;                        // é•¿æŒ‰è®¡æ—¶
  28          bit Key_Flag1;                          // è®¡æ—¶æ ‡å¿—ä½
  29          idata uchar Uart_Recv[10];                    // ä¸²å£æ¥æ”¶æ•°ç»„
  30          uchar Uart_Recv_Index;                      // ä¸²å£æ¥æ”¶æ•°ç»„æŒ‡é’ˆ
  31          uint Syt_Flag;                          // ç³»ç»Ÿè®¡æ—¶
  32          bit Time_Syt_Flag;                        // ç³»ç»Ÿè®¡æ—¶å¼€å§‹æ ‡å¿—ä½
  33          bit Uart_Enable_Flag;                     // ä¸²å£ä½¿èƒ½æ ‡å¿—ä½
  34          idata uchar Clock_Set[6] = {2, 3, 5, 9, 5, 5};          // æ—¶é’Ÿè®¾ç½®
  35          uchar Clock_Set_Index;
  36          idata uchar Alarm[3] = {0, 0, 0};        // åˆå§‹é—¹é’Ÿ
  37          idata uchar Alarm_Set[6] = {0, 0, 0, 0, 0, 0}; // é—¹é’Ÿè®¾ç½®
  38          uint Timer_700Ms;                // æ—¶é’Ÿè®¾ç½®é—¹é’Ÿè®¾ç½®è®¡æ—¶
  39          bit Seg_Star_Flag2;                // é—ªçƒæ ‡å¿—ä½
  40          bit Alarm_Enable_Flag;               // é—¹é’Ÿä½¿èƒ½æ ‡å¿—ä½
  41          uchar Key_Input_Flag;              // è¾“å…¥åä½ä¸ªä½æ ‡å¿—ä½
  42          idata uchar Clock[3];              // è®¾ç½®æ—¶é’Ÿä¿å­˜
  43          idata uchar E2PROM_Alarm[3];           // é—¹é’Ÿä¿å­˜
  44          float AD_Rb2_Output;               // Rb2è¾“å‡º
  45          uchar Term_Led;                  // å‘¨æœŸ
  46          uchar Led_Lever;                 // ç­‰çº§
  47          uchar Led_Pos;                   // LEDæ‰«æ
  48          float DA_Output;                 // DAè¾“å‡º
  49          uchar Timer_Count;                 // ä¸²å£æ—¶é—´è®¡æ•°
  50          // é”®ç›˜æ˜ å°„
  51          uchar key_to_num(uchar key)
  52          {
  53   1        switch (key)
  54   1        {
C51 COMPILER V9.59.0.0   MAIN                                                              01/27/2024 10:56:40 PAGE 2   

  55   2        case 4:
  56   2          return 0;
  57   2        case 8:
  58   2          return 1;
  59   2        case 12:
  60   2          return 2;
  61   2        case 16:
  62   2          return 3;
  63   2        case 9:
  64   2          return 4;
  65   2        case 13:
  66   2          return 5;
  67   2        case 17:
  68   2          return 6;
  69   2        case 10:
  70   2          return 7;
  71   2        case 14:
  72   2          return 8;
  73   2        case 18:
  74   2          return 9;
  75   2        default:
  76   2          return 100;
  77   2        }
  78   1      }
  79          /* é”®ç›˜å¤„ç†å‡½æ•° */
  80          void Key_Proc()
  81          {
  82   1        static uchar Key_Val, Key_Down, Key_Old, Key_Up; // æŒ‰é”®ä¸“ç”¨å˜é‡
  83   1        uchar i;
  84   1        if (Key_Slow_Down)
  85   1          return;
  86   1        Key_Slow_Down = 1; // é”®ç›˜å‡é€Ÿç¨‹åº
  87   1      
  88   1        Key_Val = Key_Read();           // å®æ—¶è¯»å–é”®ç å€¼
  89   1        Key_Down = Key_Val & (Key_Old ^ Key_Val); // æ•æ‰æŒ‰é”®ä¸‹é™æ²¿
  90   1        Key_Up = ~Key_Val & (Key_Old ^ Key_Val);  // æ•æ‰æŒ‰é”®ä¸Šé™æ²¿
  91   1        Key_Old = Key_Val;              // è¾…åŠ©æ‰«æå˜é‡
  92   1      
  93   1        /*åˆå§‹ç•Œé¢æŒ‰é”® å¯†ç è¾“å…¥*/
  94   1        if (Seg_Disp_Mode == 0 && Pass_Input_Index < 8)
  95   1        {
  96   2          uchar input_data;
  97   2          input_data = key_to_num(Key_Down);
  98   2          // æœ‰æ•ˆè¾“å…¥
  99   2          if (input_data < 100)
 100   2          {
 101   3            Pass_Input[Pass_Input_Index] = input_data;
 102   3            Pass_Input_Index++;
 103   3          }
 104   2        }
 105   1        if (Seg_Disp_Mode == 0)
 106   1        {
 107   2          // é•¿æŒ‰ è·³è¿‡å¯†ç è¾“å…¥
 108   2          if (Key_Down == 5)
 109   2            Key_Flag = 1;
 110   2          if (Timer_3000Ms >= 3000) // åˆ¤å®šä¸ºé•¿æŒ‰
 111   2          {
 112   3            if (Key_Old == 5)
 113   3              Seg_Disp_Mode = 1; // è¿›å…¥ä¸»ç•Œé¢
 114   3            if (Key_Up == 5)
 115   3            {
 116   4              Timer_3000Ms = Key_Flag = 0;
C51 COMPILER V9.59.0.0   MAIN                                                              01/27/2024 10:56:40 PAGE 3   

 117   4            }
 118   3          }
 119   2          else
 120   2          {
 121   3            if (Key_Up == 5)
 122   3              Timer_3000Ms = Key_Flag = 0;
 123   3          }
 124   2          switch (Key_Down)
 125   2          {
 126   3          case 7:                        // ç¡®è®¤
 127   3            if (Pass_Input_Index == 8 && Seg_Disp_Mode == 0) // å¯†ç è¾“å®Œ
 128   3            {
 129   4              i = 0;
 130   4              while (Pass_Input[i] == Pass_Word[i]) // å¾ªç¯åˆ¤æ–­
 131   4              {
 132   5                i++;
 133   5                if (i == 8)
 134   5                  break; // é˜²æ­¢å¾ªç¯è¶Šç•Œåˆ¤æ–­
 135   5              }
 136   4              if (i == 8) // å¯†ç è¾“å…¥æ­£ç¡®
 137   4              {
 138   5                Seg_Disp_Mode = 1; // è¿›å…¥ä¸»ç•Œé¢
 139   5                Pass_Input_Index = 0;
 140   5                Beep(0);
 141   5              }
 142   4              else
 143   4              {
 144   5                Pass_Input_Index = 0;
 145   5                for (i = 0; i < 8; i++)
 146   5                  Pass_Input[i] = 11; // è¾“å…¥å†…å®¹æ¸…ç©º
 147   5                Beep(1);
 148   5              }
 149   4            }
 150   3            break;
 151   3          case 6: // åˆ é™¤
 152   3            if (Pass_Input_Index != 0)
 153   3            {
 154   4              Pass_Input_Index--;
 155   4              Seg_Buf[7 - Pass_Input_Index] = 11;
 156   4            }
 157   3            break;
 158   3          }
 159   2        }
 160   1        /*ç³»ç»Ÿä¸»ç•Œé¢æŒ‰é”®*/
 161   1        if ((Seg_Disp_Mode == 1 || Seg_Disp_Mode == 2) && (Uart_Enable_Flag == 0)) // æ—¶é’Ÿ è¶…å£°æ³¢æ¸©åº¦
 162   1        {
 163   2          // é•¿æŒ‰ä¿¡æ¯æ˜¾ç¤ºæŒ‰é”®å¯è¿›å…¥ä¿¡æ¯æ˜¾ç¤ºç•Œé¢ æ¾æ‰‹åè¿” å›æ—¶é’Ÿæ˜¾ç¤ºç•Œé¢
 164   2          if (Key_Down == 7)
 165   2            Key_Flag1 = 1;
 166   2          if (Timer_2000Ms > 2000) // åˆ¤å®šä¸ºé•¿æŒ‰
 167   2          {
 168   3            if (Key_Old == 7)
 169   3              Seg_Disp_Mode = 2;
 170   3            if (Key_Up == 7) // æ•æ‰åˆ°ä¸Šå‡æ²¿
 171   3            {
 172   4              Seg_Disp_Mode = 1;
 173   4              Timer_2000Ms = Key_Flag1 = 0; // å¤ä½ï¼Œä¾¿äºä¸‹æ¬¡
 174   4            }
 175   3          }
 176   2          else
 177   2          {
 178   3            if (Key_Up == 7)          // æ•æ‰åˆ°ä¸Šå‡æ²¿
C51 COMPILER V9.59.0.0   MAIN                                                              01/27/2024 10:56:40 PAGE 4   

 179   3              Timer_2000Ms = Key_Flag1 = 0; // å¤ä½ï¼Œä¾¿äºä¸‹æ¬¡
 180   3          }
 181   2      
 182   2          switch (Key_Down)
 183   2          {
 184   3          case 11: // ä¸²å£å¼€
 185   3            Uart_Enable_Flag = 1;
 186   3            break;
 187   3          case 6: // æ—¶é’Ÿè®¾ç½®ç•Œé¢
 188   3            for (i = 0; i < 3; i++)
 189   3            {
 190   4              Clock_Set[i * 2] = Clock_Crl[i] / 10;
 191   4              Clock_Set[i * 2 + 1] = Clock_Crl[i] % 10;
 192   4            }
 193   3            Seg_Disp_Mode = 3;
 194   3            break;
 195   3          case 5: // é—¹é’Ÿè®¾ç½®
 196   3            Seg_Disp_Mode = 4;
 197   3            break;
 198   3          case 4: // é—¹é’Ÿä½¿èƒ½
 199   3            Alarm_Enable_Flag = 1;
 200   3            break;
 201   3          }
 202   2        }
 203   1      
 204   1        /*æ—¶é’Ÿè®¾ç½®é—¹é’Ÿè®¾ç½®æŒ‰é”®*/
 205   1        if ((Seg_Disp_Mode == 3 || Seg_Disp_Mode == 4) && (Uart_Enable_Flag == 0))
 206   1        {
 207   2          switch (Key_Down)
 208   2          {
 209   3          case 11: // å°æ—¶è®¾ç½®
 210   3            Key_Input_Flag = 0;
 211   3            Clock_Set_Index = 0;
 212   3            break;
 213   3          case 15: // åˆ†é’Ÿè®¾ç½®
 214   3            Key_Input_Flag = 2;
 215   3            Clock_Set_Index = 2;
 216   3            break;
 217   3          case 19: // ç§’é’Ÿè®¾ç½®
 218   3            Key_Input_Flag = 4;
 219   3            Clock_Set_Index = 4;
 220   3            break;
 221   3          case 7:           // ç¡®è®¤ä¿å­˜ ä¿å­˜åˆ° EEPROM å†…
 222   3            if (Seg_Disp_Mode == 3) // æ—¶é’Ÿ
 223   3            {
 224   4              Clock[0] = (Clock_Set[0] * 10 + Clock_Set[1]);
 225   4              Clock[1] = (Clock_Set[2] * 10 + Clock_Set[3]);
 226   4              Clock[2] = (Clock_Set[4] * 10 + Clock_Set[5]);
 227   4              if (Clock[0] < 23 && Clock[1] < 59 && Clock[2] < 59) // æ•°æ®åˆç†
 228   4              {
 229   5                Set_Rtc(Clock); // ä¿å­˜
 230   5                E2PROM_Read(Clock, 8, 3);
 231   5                Seg_Disp_Mode = 1;
 232   5              }
 233   4            }
 234   3            if (Seg_Disp_Mode == 4) // é—¹é’Ÿ
 235   3            {
 236   4              E2PROM_Alarm[0] = (Alarm_Set[0] * 10 + Alarm_Set[1]);
 237   4              E2PROM_Alarm[1] = (Alarm_Set[2] * 10 + Alarm_Set[3]);
 238   4              E2PROM_Alarm[2] = (Alarm_Set[4] * 10 + Alarm_Set[5]);
 239   4              if (E2PROM_Alarm[0] < 23 && E2PROM_Alarm[1] < 59 && E2PROM_Alarm[2] < 59) // æ•°æ®åˆç†
 240   4              {
C51 COMPILER V9.59.0.0   MAIN                                                              01/27/2024 10:56:40 PAGE 5   

 241   5                E2PROM_Read(E2PROM_Alarm, 0, 3);
 242   5                Seg_Disp_Mode = 1;
 243   5              }
 244   4            }
 245   3            break;
 246   3          case 6: // å–æ¶ˆä¿å­˜
 247   3            if (Seg_Disp_Mode == 3)
 248   3            {
 249   4              Set_Rtc(Clock_Crl); // ä¿å­˜åŸæ¥å€¼
 250   4            }
 251   3            if (Seg_Disp_Mode == 4)
 252   3            {
 253   4              E2PROM_Alarm[0] = E2PROM_Alarm[1] = E2PROM_Alarm[2] = 0;
 254   4            }
 255   3            break;
 256   3          case 5: // ä¸²å£
 257   3            Uart_Enable_Flag = 1;
 258   3            break;
 259   3          }
 260   2          if (Clock_Set_Index < (Key_Input_Flag + 2)) // è¾“å…¥ä¸¤ä¸ªä¹‹åä¸èƒ½å†è¾“
 261   2          {
 262   3            switch (Key_Down) // æ—¶é—´è¾“å…¥
 263   3            {
 264   4            case 4:
 265   4              if (Seg_Disp_Mode == 3)
 266   4                Clock_Set[Clock_Set_Index] = 0;
 267   4              else if (Seg_Disp_Mode == 4)
 268   4                Alarm_Set[Clock_Set_Index] = 0;
 269   4              Clock_Set_Index++;
 270   4              break;
 271   4            case 8:
 272   4              if (Seg_Disp_Mode == 3)
 273   4                Clock_Set[Clock_Set_Index] = 1;
 274   4              else if (Seg_Disp_Mode == 4)
 275   4                Alarm_Set[Clock_Set_Index] = 1;
 276   4              Clock_Set_Index++;
 277   4              break;
 278   4            case 12:
 279   4              if (Seg_Disp_Mode == 3)
 280   4                Clock_Set[Clock_Set_Index] = 2;
 281   4              else if (Seg_Disp_Mode == 4)
 282   4                Alarm_Set[Clock_Set_Index] = 2;
 283   4              Clock_Set_Index++;
 284   4              break;
 285   4            case 16:
 286   4              if (Seg_Disp_Mode == 3)
 287   4                Clock_Set[Clock_Set_Index] = 3;
 288   4              else if (Seg_Disp_Mode == 4)
 289   4                Alarm_Set[Clock_Set_Index] = 3;
 290   4              Clock_Set_Index++;
 291   4              break;
 292   4            case 9:
 293   4              if (Seg_Disp_Mode == 3)
 294   4                Clock_Set[Clock_Set_Index] = 4;
 295   4              else if (Seg_Disp_Mode == 4)
 296   4                Alarm_Set[Clock_Set_Index] = 4;
 297   4              Clock_Set_Index++;
 298   4              break;
 299   4            case 13:
 300   4              if (Seg_Disp_Mode == 3)
 301   4                Clock_Set[Clock_Set_Index] = 5;
 302   4              else if (Seg_Disp_Mode == 4)
C51 COMPILER V9.59.0.0   MAIN                                                              01/27/2024 10:56:40 PAGE 6   

 303   4                Alarm_Set[Clock_Set_Index] = 5;
 304   4              Clock_Set_Index++;
 305   4              break;
 306   4            case 17:
 307   4              if (Seg_Disp_Mode == 3)
 308   4                Clock_Set[Clock_Set_Index] = 6;
 309   4              else if (Seg_Disp_Mode == 4)
 310   4                Alarm_Set[Clock_Set_Index] = 6;
 311   4              Clock_Set_Index++;
 312   4              break;
 313   4            case 10:
 314   4              if (Seg_Disp_Mode == 3)
 315   4                Clock_Set[Clock_Set_Index] = 7;
 316   4              else if (Seg_Disp_Mode == 4)
 317   4                Alarm_Set[Clock_Set_Index] = 7;
 318   4              Clock_Set_Index++;
 319   4              break;
 320   4            case 14:
 321   4              if (Seg_Disp_Mode == 3)
 322   4                Clock_Set[Clock_Set_Index] = 8;
 323   4              else if (Seg_Disp_Mode == 4)
 324   4                Alarm_Set[Clock_Set_Index] = 8;
 325   4              Clock_Set_Index++;
 326   4              break;
 327   4            case 18:
 328   4              if (Seg_Disp_Mode == 3)
 329   4                Clock_Set[Clock_Set_Index] = 9;
 330   4              else if (Seg_Disp_Mode == 4)
 331   4                Alarm_Set[Clock_Set_Index] = 9;
 332   4              Clock_Set_Index++;
 333   4              break;
 334   4            }
 335   3          }
 336   2        }
 337   1      }
 338          
 339          /* ä¿¡æ¯å¤„ç†å‡½æ•° */
 340          void Seg_Proc()
 341          {
 342   1        unsigned char i;
 343   1        //  if(Seg_Slow_Down) return;
 344   1        //  Seg_Slow_Down = 1;//æ•°ç ç®¡å‡é€Ÿç¨‹åº
 345   1      
 346   1        switch (Seg_Slow_Down)
 347   1        {
 348   2        case 100: // æ—¶é’Ÿè¯»å–
 349   2          Seg_Slow_Down += 1;
 350   2          Read_Rtc(Clock_Crl);
 351   2          break;
 352   2        case 200: // è¶…å£°æ³¢
 353   2          Seg_Slow_Down += 1;
 354   2          ultrasonic = Ut_Wave_Data();
 355   2          if ((ultrasonic_Ture - ultrasonic < 10) || (ultrasonic - ultrasonic_Ture < 10))
 356   2            ultrasonic_Ture = ultrasonic;
 357   2          break;
 358   2        case 300: // AD
 359   2          Seg_Slow_Down += 1;
 360   2          AD_Output = Ad_Read(0x43);        // å…‰æ•ç”µé˜»
 361   2          AD_Rb2_Output = Ad_Read(0x41) / 51.0; // ç”µä½å™¨è¾“å‡º
 362   2          Da_Write(DA_Output);          // DAè¾“å‡º
 363   2          Sun_Flag = (AD_Output > 100);
 364   2          break;
C51 COMPILER V9.59.0.0   MAIN                                                              01/27/2024 10:56:40 PAGE 7   

 365   2        case 400: // æ¸©åº¦
 366   2          Seg_Slow_Down += 1;
 367   2          Temp = Read_t();
 368   2          break;
 369   2        }
 370   1      
 371   1        Seg_Point[5] = (Seg_Disp_Mode == 2);
 372   1        switch (Seg_Disp_Mode)
 373   1        {
 374   2        case 0: // ç³»ç»Ÿåˆå§‹ç•Œé¢
 375   2          if (Pass_Input_Index != 0)
 376   2          {
 377   3            for (i = 0; i < Pass_Input_Index; i++)
 378   3              Seg_Buf[7 - i] = Pass_Input[Pass_Input_Index - i - 1];
 379   3          }
 380   2          else
 381   2          {
 382   3            for (i = 0; i < 8; i++)
 383   3              Seg_Buf[i] = 11;
 384   3          }
 385   2          break;
 386   2        case 1: // ä¸»ç•Œé¢
 387   2          for (i = 0; i < 3; i++)
 388   2          {
 389   3            Seg_Buf[i * 2 + i] = Clock_Crl[i] / 10;
 390   3            Seg_Buf[i * 2 + i + 1] = Clock_Crl[i] % 10;
 391   3          }
 392   2          Seg_Buf[2] = Seg_Buf[5] = Seg_Star_Flag ? 10 : 11;
 393   2          break;
 394   2        case 2: // è¶…å£°æ³¢ å…‰ æ¸©åº¦
 395   2          Seg_Buf[0] = ultrasonic_Ture / 10;
 396   2          Seg_Buf[1] = ultrasonic_Ture % 10;
 397   2          Seg_Buf[2] = (unsigned char)Sun_Flag;
 398   2          Seg_Buf[3] = 11;
 399   2          Seg_Buf[4] = (unsigned char)Temp / 10;
 400   2          Seg_Buf[5] = (unsigned char)Temp % 10;
 401   2          Seg_Buf[6] = (unsigned int)(Temp * 10) % 10;
 402   2          Seg_Buf[7] = 12;
 403   2          break;
 404   2        case 3: // æ—¶é’Ÿè®¾ç½®
 405   2          Seg_Buf[0] = Clock_Set[0];
 406   2          Seg_Buf[1] = Clock_Set[1];
 407   2          Seg_Buf[3] = Clock_Set[2];
 408   2          Seg_Buf[4] = Clock_Set[3];
 409   2          Seg_Buf[6] = Clock_Set[4];
 410   2          Seg_Buf[7] = Clock_Set[5];
 411   2      
 412   2          Seg_Buf[2] = Seg_Buf[5] = Seg_Star_Flag2 ? 10 : 11;
 413   2          break;
 414   2        case 4: // é—¹é’Ÿè®¾ç½®
 415   2          Seg_Buf[0] = Alarm_Set[0];
 416   2          Seg_Buf[1] = Alarm_Set[1];
 417   2          Seg_Buf[3] = Alarm_Set[2];
 418   2          Seg_Buf[4] = Alarm_Set[3];
 419   2          Seg_Buf[6] = Alarm_Set[4];
 420   2          Seg_Buf[7] = Alarm_Set[5];
 421   2      
 422   2          Seg_Buf[2] = Seg_Buf[5] = Seg_Star_Flag2 ? 10 : 11;
 423   2          break;
 424   2        }
 425   1      }
 426          
C51 COMPILER V9.59.0.0   MAIN                                                              01/27/2024 10:56:40 PAGE 8   

 427          /* å…¶ä»–æ˜¾ç¤ºå‡½æ•° */
 428          void Led_Proc()
 429          {
 430   1      
 431   1        ucLed[0] = (Seg_Disp_Mode == 0);
 432   1        ucLed[1] = (Seg_Disp_Mode == 1);
 433   1        ucLed[2] = (Seg_Disp_Mode == 3);
 434   1        ucLed[3] = (Seg_Disp_Mode == 4);
 435   1        ucLed[4] = (Seg_Disp_Mode == 2);
 436   1      
 437   1        Led_Lever = ((AD_Rb2_Output) * 2.0);
 438   1        // DA
 439   1        DA_Output = (Sun_Flag ? 1 : 5);
 440   1      }
 441          
 442          /*ä¸²å£*/
 443          void Uart_Sent_Proc()
 444          {
 445   1        if (Uart_Slow_Down)
 446   1          return;
 447   1        Uart_Slow_Down = 1;
 448   1        // æ¯åˆ°ä¸€ä¸ªæ•´ç‚¹åå•ç‰‡æœºå‘ä¸Šä½æœºå‘é€æŒ‡ä»¤
 449   1        if (Clock_Crl[1] == 0 && Clock_Crl[2] == 0) // æ•´ç‚¹
 450   1        {
 451   2          printf("Time = %d:%d:%d", (unsigned int)Clock_Crl[0], (unsigned int)Clock_Crl[1], (unsigned int)Clock_Cr
             -l[2]);
 452   2        }
 453   1      
 454   1        if (Seg_Disp_Mode == 1) // æ—¶é’Ÿæ˜¾ç¤ºç•Œé¢
 455   1        {
 456   2          if (Timer_Count == 2) // åœ¨æ—¶é’Ÿæ˜¾ç¤ºç•Œé¢æ—¶æ¯é—´éš”ä¸‰ç§’å•ç‰‡æœºå‘ä¸Šä½æœºå‘é€æŒ‡ä»¤
 457   2            printf("%d:%d-%dCM_%dC", (unsigned int)Clock_Crl[0], (unsigned int)Clock_Crl[1], (unsigned int)ultrason
             -ic_Ture, (unsigned int)Temp);
 458   2        }
 459   1      }
 460          
 461          /*ä¸²å£å¤„ç†å‡½æ•°*/
 462          void Uart_Proc()
 463          {
 464   1        unsigned char a; // Forå¾ªç¯
 465   1        unsigned char i; // whileå¾ªç¯
 466   1        if (Uart_Recv_Index == 0)
 467   1          return;
 468   1        if (Syt_Flag >= 10)
 469   1        {
 470   2          Syt_Flag = Time_Syt_Flag = 0; // å¤ä½
 471   2          if (Uart_Enable_Flag)     // ä¸²å£å¼€å§‹ä½¿èƒ½
 472   2          {
 473   3            if ((Seg_Disp_Mode == 1 || Seg_Disp_Mode == 2))
 474   3            {
 475   4              if (Uart_Recv_Index == 4) // ä¸»ç•Œé¢ä¸²å£åŠŸèƒ½
 476   4              {
 477   5                if (Uart_Recv[0] == 'D' && Uart_Recv[1] == 'I' && Uart_Recv[2] == 'S' && Uart_Recv[3] == 'P') // ä¿¡æ
             -¯æ˜¾ç¤º
 478   5                {
 479   6                  Seg_Disp_Mode = 2; // ä¿¡æ¯æ˜¾ç¤ºç•Œé¢
 480   6                }
 481   5                if (Uart_Recv[0] == 'C' && Uart_Recv[1] == 'K' && Uart_Recv[2] == 'G' && Uart_Recv[3] == 'B') // ä¸²å
             -£å…³
 482   5                {
 483   6                  Uart_Enable_Flag = 0; // å…³é—­ä¸²å£åŠŸèƒ½
 484   6                  Seg_Disp_Mode = 1;
C51 COMPILER V9.59.0.0   MAIN                                                              01/27/2024 10:56:40 PAGE 9   

 485   6                }
 486   5                if (Uart_Recv[0] == 'S' && Uart_Recv[1] == 'Z' && Uart_Recv[2] == 'S' && Uart_Recv[3] == 'Z') // æ—¶é
             -’Ÿè®¾ç½®
 487   5                {
 488   6                  Seg_Disp_Mode = 3; // æ—¶é’Ÿè®¾ç½®ç•Œé¢
 489   6                }
 490   5                if (Uart_Recv[0] == 'N' && Uart_Recv[1] == 'Z' && Uart_Recv[2] == 'S' && Uart_Recv[3] == 'Z') // é—¹é
             -’Ÿè®¾ç½®
 491   5                {
 492   6                  Seg_Disp_Mode = 4; // é—¹é’Ÿè®¾ç½®ç•Œé¢
 493   6                }
 494   5                if (Uart_Recv[0] == 'N' && Uart_Recv[1] == 'Z' && Uart_Recv[2] == 'K' && Uart_Recv[3] == 'G') // é—¹é
             -’Ÿè®¾ç½®
 495   5                {
 496   6                  Alarm_Enable_Flag = 1; // é—¹é’Ÿä½¿èƒ½
 497   6                }
 498   5              }
 499   4            }
 500   3            if ((Seg_Disp_Mode == 3 || Seg_Disp_Mode == 4))
 501   3            {
 502   4              if (Uart_Recv_Index == 6) // æ—¶é’Ÿé—¹é’Ÿè®¾ç½®
 503   4              {
 504   5                // å°æ—¶è®¾ç½®ï¼šHSetXX
 505   5                if (Uart_Recv[0] == 'H' && Uart_Recv[1] == 'S' && Uart_Recv[2] == 'e' && Uart_Recv[3] == 't') // é—¹é
             -’Ÿè®¾ç½®
 506   5                {
 507   6                  if (((Uart_Recv[4] >= '0') && (Uart_Recv[4] <= '9')) && ((Uart_Recv[5] >= '0') && (Uart_Recv[5] <= '
             -9'))) // 0-9
 508   6                  {
 509   7                    if (Seg_Disp_Mode == 3) // æ—¶é’Ÿè®¾ç½®
 510   7                    {
 511   8                      Clock_Set[0] = Uart_Recv[4] - 48;
 512   8                      Clock_Set[1] = Uart_Recv[5] - 48;
 513   8                    }
 514   7                    else // é—¹é’Ÿè®¾ç½®
 515   7                    {
 516   8                      Alarm_Set[0] = Uart_Recv[4] - 48;
 517   8                      Alarm_Set[1] = Uart_Recv[5] - 48;
 518   8                    }
 519   7                  }
 520   6                }
 521   5                // åˆ†é’Ÿè®¾ç½®ï¼šMSetXX
 522   5                if (Uart_Recv[0] == 'M' && Uart_Recv[1] == 'S' && Uart_Recv[2] == 'e' && Uart_Recv[3] == 't') // é—¹é
             -’Ÿè®¾ç½®
 523   5                {
 524   6                  if (((Uart_Recv[4] >= '0') && (Uart_Recv[4] <= '9')) && ((Uart_Recv[5] >= '0') && (Uart_Recv[5] <= '
             -9'))) // 0-9
 525   6                  {
 526   7                    if (Seg_Disp_Mode == 3)
 527   7                    {
 528   8                      Clock_Set[2] = Uart_Recv[4] - 48;
 529   8                      Clock_Set[3] = Uart_Recv[5] - 48;
 530   8                    }
 531   7                    else
 532   7                    {
 533   8                      Alarm_Set[2] = Uart_Recv[4] - 48;
 534   8                      Alarm_Set[3] = Uart_Recv[5] - 48;
 535   8                    }
 536   7                  }
 537   6                }
 538   5                // ç§’é’Ÿè®¾ç½®ï¼šSSetXX
 539   5                if (Uart_Recv[0] == 'S' && Uart_Recv[1] == 'S' && Uart_Recv[2] == 'e' && Uart_Recv[3] == 't') // é—¹é
C51 COMPILER V9.59.0.0   MAIN                                                              01/27/2024 10:56:40 PAGE 10  

             -’Ÿè®¾ç½®
 540   5                {
 541   6                  if (((Uart_Recv[4] >= '0') && (Uart_Recv[4] <= '9')) && ((Uart_Recv[5] >= '0') && (Uart_Recv[5] <= '
             -9'))) // 0-9
 542   6                  {
 543   7                    if (Seg_Disp_Mode == 3)
 544   7                    {
 545   8                      Clock_Set[4] = Uart_Recv[4] - 48;
 546   8                      Clock_Set[5] = Uart_Recv[5] - 48;
 547   8                    }
 548   7                    else
 549   7                    {
 550   8                      Alarm_Set[4] = Uart_Recv[4] - 48;
 551   8                      Alarm_Set[5] = Uart_Recv[5] - 48;
 552   8                    }
 553   7                  }
 554   6                }
 555   5              }
 556   4              if (Uart_Recv_Index == 4) // å…³é—­ä¸²å£
 557   4              {
 558   5                if (Uart_Recv[0] == 'C' && Uart_Recv[1] == 'K' && Uart_Recv[2] == 'G' && Uart_Recv[3] == 'B') // ä¸²å
             -£å…³
 559   5                  Uart_Enable_Flag = 0;
 560   5              }
 561   4            }
 562   3          }
 563   2          if (Seg_Disp_Mode == 1) // åœ¨æ—¶é’Ÿæ˜¾ç¤ºç•Œé¢æ—¶ä¸Šä½æœºå¯å‘é€ä¿®æ”¹å¯†ç æŒ‡ä»¤
 564   2          {
 565   3            if (Uart_Recv_Index == 10)
 566   3            {
 567   4              if (Uart_Recv[0] == 'X' && Uart_Recv[1] == 'G')
 568   4              {
 569   5                i = 2;
 570   5                while (((Uart_Recv[i] >= '0') && (Uart_Recv[4] <= '9')))
 571   5                {
 572   6                  i++;
 573   6                  if (i == 8)
 574   6                    break;
 575   6                }
 576   5                if (i == 8)
 577   5                {
 578   6                  for (a = 0; a < 8; a++)
 579   6                  {
 580   7                    Pass_Word[a] = Uart_Recv[a + 2] - 48;
 581   7                    Seg_Disp_Mode = 0;
 582   7                  }
 583   6                }
 584   5              }
 585   4            }
 586   3          }
 587   2          memset(Uart_Recv, 0, Uart_Recv_Index);
 588   2          Uart_Recv_Index = 0;
 589   2        }
 590   1      }
 591          /*å®šæ—¶å™¨1ä¸­æ–­åˆå§‹åŒ–å‡½æ•°*/
 592          void Timer1_Init(void) // 125å¾®ç§’@12.000MHz
 593          {
 594   1        AUXR &= 0xBF; // å®šæ—¶å™¨æ—¶é’Ÿ12Tæ¨¡å¼
 595   1        TMOD &= 0x0F; // è®¾ç½®å®šæ—¶å™¨æ¨¡å¼
 596   1        TL1 = 0x83;   // è®¾ç½®å®šæ—¶åˆå§‹å€¼
 597   1        TH1 = 0xFF;   // è®¾ç½®å®šæ—¶åˆå§‹å€¼
 598   1        TF1 = 0;    // æ¸…é™¤TF1æ ‡å¿—
C51 COMPILER V9.59.0.0   MAIN                                                              01/27/2024 10:56:40 PAGE 11  

 599   1        TR1 = 1;    // å®šæ—¶å™¨1å¼€å§‹è®¡æ—¶
 600   1        ET1 = 1;    // å®šæ—¶å™¨ä¸­æ–­1æ‰“å¼€
 601   1      }
 602          
 603          /* å®šæ—¶å™¨0ä¸­æ–­åˆå§‹åŒ–å‡½æ•° */
 604          void Timer0Init(void) // 1æ¯«ç§’@12.000MHz
 605          {
 606   1        AUXR &= 0x7F; // å®šæ—¶å™¨æ—¶é’Ÿ12Tæ¨¡å¼
 607   1        TMOD &= 0xF0; // è®¾ç½®å®šæ—¶å™¨æ¨¡å¼
 608   1        TL0 = 0x18;   // è®¾ç½®å®šæ—¶åˆå§‹å€¼
 609   1        TH0 = 0xFC;   // è®¾ç½®å®šæ—¶åˆå§‹å€¼
 610   1        TF0 = 0;    // æ¸…é™¤TF0æ ‡å¿—
 611   1        TR0 = 1;    // å®šæ—¶å™¨0å¼€å§‹è®¡æ—¶
 612   1        ET0 = 1;    // å®šæ—¶å™¨ä¸­æ–­0æ‰“å¼€
 613   1        EA = 1;     // æ€»ä¸­æ–­æ‰“å¼€
 614   1      }
 615          
 616          /* å®šæ—¶å™¨0ä¸­æ–­æœåŠ¡å‡½æ•° */
 617          void Timer0Server() interrupt 1
 618          {
 619   1        if (++Uart_Slow_Down == 1000)
 620   1        {
 621   2          Uart_Slow_Down = 0;
 622   2          if (++Timer_Count == 3)
 623   2            Timer_Count = 0;
 624   2        }
 625   1        if (++Key_Slow_Down == 10)
 626   1          Key_Slow_Down = 0; // é”®ç›˜å‡é€Ÿä¸“ç”¨
 627   1        if (++Seg_Slow_Down == 500)
 628   1          Seg_Slow_Down = 0; // æ•°ç ç®¡å‡é€Ÿä¸“ç”¨
 629   1        if (++Seg_Pos == 8)
 630   1          Seg_Pos = 0; // æ•°ç ç®¡æ˜¾ç¤ºä¸“ç”¨
 631   1        Seg_Disp(Seg_Pos, Seg_Buf[Seg_Pos], Seg_Point[Seg_Pos]);
 632   1      
 633   1        if (Key_Flag == 1)
 634   1        {
 635   2          if (++Timer_3000Ms == 4000) // é•¿æŒ‰
 636   2          {
 637   3            Timer_3000Ms = 4000;
 638   3          }
 639   2        }
 640   1      
 641   1        if (++Timer_500Ms == 500) // æ—¶é—´é—´éš”ç¬¦é—ªçƒ
 642   1        {
 643   2          Timer_500Ms = 0;
 644   2          Seg_Star_Flag ^= 1;
 645   2        }
 646   1      
 647   1        if (++Timer_700Ms == 700) // æ—¶é—´é—¹é’Ÿè®¾ç½®é—´éš”ç¬¦
 648   1        {
 649   2          Timer_700Ms = 0;
 650   2          Seg_Star_Flag2 ^= 1;
 651   2        }
 652   1      
 653   1        if (Key_Flag1)
 654   1        {
 655   2          if (++Timer_2000Ms == 3000) // é•¿æŒ‰
 656   2            Timer_2000Ms = 3000;
 657   2        }
 658   1      
 659   1        // ä¸²å£
 660   1        if (Time_Syt_Flag)
C51 COMPILER V9.59.0.0   MAIN                                                              01/27/2024 10:56:40 PAGE 12  

 661   1          Syt_Flag++;
 662   1      
 663   1        // ledäº®åº¦ç­‰çº§
 664   1        if (++Term_Led == 10)
 665   1          Term_Led = 0;
 666   1      }
 667          
 668          /*å®šæ—¶å™¨1æœåŠ¡å‡½æ•°*/
 669          void Timer1Server() interrupt 3
 670          {
 671   1        if (++Led_Pos == 8)
 672   1          Led_Pos = 0;
 673   1      
 674   1        if (Term_Led <= Led_Lever)
 675   1          Led_Disp(Led_Pos, ucLed[Led_Pos]);
 676   1        else
 677   1          Led_Disp(Led_Pos, 0);
 678   1      }
 679          
 680          /*ä¸²å£*/
 681          void Uart1Server() interrupt 4
 682          {
 683   1        if (RI == 1) // å¼€å§‹æ¥å—æ•°æ®
 684   1        {
 685   2          Time_Syt_Flag = 1;
 686   2          Syt_Flag = 0;
 687   2          Uart_Recv[Uart_Recv_Index] = SBUF;
 688   2          Uart_Recv_Index++;
 689   2          RI = 0;
 690   2        }
 691   1        if (Uart_Recv_Index > 10)
 692   1          Uart_Recv_Index = 0;
 693   1      }
 694          
 695          /* Main */
 696          void main()
 697          {
 698   1      
 699   1        while (Read_t() == 85)
 700   1          ;
 701   1        System_Init();
 702   1        Timer0Init();
 703   1        Set_Rtc(Clock_Crl);
 704   1        UartInit();
 705   1        E2PROM_Write(E2PROM_Alarm, 0, 3);
 706   1        Alarm[0] = E2PROM_Alarm[0];
 707   1        Alarm[1] = E2PROM_Alarm[1];
 708   1        Alarm[2] = E2PROM_Alarm[2];
 709   1        E2PROM_Write(Clock, 8, 3);
 710   1        Clock_Crl[0] = Clock[0];
 711   1        Clock_Crl[1] = Clock[1];
 712   1        Clock_Crl[2] = Clock[2];
 713   1      
 714   1        Timer1_Init();
 715   1        while (1)
 716   1        {
 717   2          Uart_Sent_Proc();
 718   2          Key_Proc();
 719   2          Seg_Proc();
 720   2          Led_Proc();
 721   2          Uart_Proc();
 722   2        }
C51 COMPILER V9.59.0.0   MAIN                                                              01/27/2024 10:56:40 PAGE 13  

 723   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3138    ----
   CONSTANT SIZE    =     31    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     55       3
   IDATA SIZE       =     66    ----
   BIT SIZE         =      8    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
