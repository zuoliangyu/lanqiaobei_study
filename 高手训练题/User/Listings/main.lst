C51 COMPILER V9.59.0.0   MAIN                                                              01/27/2024 21:35:14 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Driver) DEBUG OBJECTEXTEND PRI
                    -NT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /* å¤´æ–‡ä»¶å£°æ˜åŒº */
   2          #include "main.h"
   3          
   4          /* å˜é‡å£°æ˜åŒº */
   5          
   6          uchar Key_Slow_Down;                      // æŒ‰é”®å‡é€Ÿä¸“ç”¨å˜é‡
   7          uint Uart_Slow_Down;                      // æŒ‰é”®å‡é€Ÿä¸“ç”¨å˜é‡
   8           uchar Seg_Buf[8] = {10, 10, 10, 10, 10, 10, 10, 10};   // æ•°ç ç®¡æ˜¾ç¤ºæ•°æ®å­˜æ”¾æ•°ç»„
   9           uchar Seg_Point[8] = {0, 0, 0, 0, 0, 0, 0, 0};     // æ•°ç ç®¡å°æ•°ç‚¹æ•°æ®å­˜æ”¾æ•°ç»„
  10          uchar Seg_Pos;                          // æ•°ç ç®¡æ‰«æä¸“ç”¨å˜é‡
  11          uint Seg_Slow_Down;                       // æ•°ç ç®¡å‡é€Ÿä¸“ç”¨å˜é‡
  12           uchar ucLed[8] = {0, 0, 0, 0, 0, 0, 0, 0};       // Ledæ˜¾ç¤ºæ•°æ®å­˜æ”¾æ•°ç»„
  13          uchar Seg_Disp_Mode;                      // æ¨¡å¼ç•Œé¢ 0-ç³»ç»Ÿåˆå§‹ç•Œé¢ 1-ä¸»ç•Œé¢ æ—¶é’Ÿ  ä¿¡æ¯
  14          uchar Pass_Word[8] = {1, 2, 3, 4, 5, 6, 7, 8};          // åˆå§‹å¯†ç 
  15           uchar Pass_Input[8] = {11, 11, 11, 11, 11, 11, 11, 11}; // å¯†ç è¾“å…¥
  16          uchar Pass_Input_Index;                     // å¯†ç è¾“å…¥æŒ‡é’ˆ
  17          uint Timer_3000Ms;                        // é•¿æŒ‰è®¡æ—¶
  18          bit Key_Flag;                         // è®¡æ—¶æ ‡å¿—ä½
  19          idata uchar Clock_Crl[3] = {23, 59, 55};            // æ—¶é’Ÿ
  20          uint Timer_500Ms;                       // æ—¶é’Ÿé—´éš”ç¬¦é—ªçƒ
  21          bit Seg_Star_Flag;                        // é—ªçƒæ ‡å¿—ä½
  22          uchar ultrasonic;                       // è¶…å£°æ³¢æµ‹è·
  23          uchar ultrasonic_Ture;                      // è¶…å£°æ³¢æµ‹è·
  24          float AD_Output;                        // ADè¾“å‡º
  25          float Temp;                           // æ¸©åº¦
  26          bit Sun_Flag;                         // æ˜¯å¦æœ‰å…‰æ ‡å¿—ä½
  27          uint Timer_2000Ms;                        // é•¿æŒ‰è®¡æ—¶
  28          bit Key_Flag1;                          // è®¡æ—¶æ ‡å¿—ä½
  29          idata uchar Uart_Recv[10];                    // ä¸²å£æ¥æ”¶æ•°ç»„
  30          uchar Uart_Recv_Index;                      // ä¸²å£æ¥æ”¶æ•°ç»„æŒ‡é’ˆ
  31          uint Syt_Flag;                          // ç³»ç»Ÿè®¡æ—¶
  32          bit Time_Syt_Flag;                        // ç³»ç»Ÿè®¡æ—¶å¼€å§‹æ ‡å¿—ä½
  33          bit Uart_Enable_Flag;                     // ä¸²å£ä½¿èƒ½æ ‡å¿—ä½
  34          idata uchar Clock_Set[6] = {2, 3, 5, 9, 5, 5};          // æ—¶é’Ÿè®¾ç½®
  35          uchar Clock_Set_Index;
  36          idata uchar Alarm[3] = {0, 0, 0};        // åˆå§‹é—¹é’Ÿ
  37          idata uchar Alarm_Set[6] = {0, 0, 0, 0, 0, 0}; // é—¹é’Ÿè®¾ç½®
  38          uint Timer_700Ms;                // æ—¶é’Ÿè®¾ç½®é—¹é’Ÿè®¾ç½®è®¡æ—¶
  39          bit Seg_Star_Flag2;                // é—ªçƒæ ‡å¿—ä½
  40          bit Alarm_Enable_Flag;               // é—¹é’Ÿä½¿èƒ½æ ‡å¿—ä½
  41          uchar Key_Input_Flag;              // è¾“å…¥åä½ä¸ªä½æ ‡å¿—ä½
  42          idata uchar Clock[3];              // è®¾ç½®æ—¶é’Ÿä¿å­˜
  43          idata uchar E2PROM_Alarm[3];           // é—¹é’Ÿä¿å­˜
  44          float AD_Rb2_Output;               // Rb2è¾“å‡º
  45          uchar Term_Led;                  // å‘¨æœŸ
  46          uchar Led_Lever;                 // ç­‰çº§
  47          uchar Led_Pos;                   // LEDæ‰«æ
  48          float DA_Output;                 // DAè¾“å‡º
  49          uchar Timer_Count;                 // ä¸²å£æ—¶é—´è®¡æ•°
  50          // é”®ç›˜æ˜ å°„
  51          uchar key_to_num(uchar key)
  52          {
  53   1        switch (key)
  54   1        {
C51 COMPILER V9.59.0.0   MAIN                                                              01/27/2024 21:35:14 PAGE 2   

  55   2        case 4:
  56   2          return 0;
  57   2        case 8:
  58   2          return 1;
  59   2        case 12:
  60   2          return 2;
  61   2        case 16:
  62   2          return 3;
  63   2        case 9:
  64   2          return 4;
  65   2        case 13:
  66   2          return 5;
  67   2        case 17:
  68   2          return 6;
  69   2        case 10:
  70   2          return 7;
  71   2        case 14:
  72   2          return 8;
  73   2        case 18:
  74   2          return 9;
  75   2        default:
  76   2          return 100;
  77   2        }
  78   1      }
  79          /* é”®ç›˜å¤„ç†å‡½æ•° */
  80          void Key_Proc()
  81          {
  82   1        static uchar Key_Val, Key_Down, Key_Old, Key_Up; // æŒ‰é”®ä¸“ç”¨å˜é‡
  83   1        uchar i;
  84   1        if (Key_Slow_Down)
  85   1          return;
  86   1        Key_Slow_Down = 1; // é”®ç›˜å‡é€Ÿç¨‹åº
  87   1      
  88   1        Key_Val = Key_Read();           // å®æ—¶è¯»å–é”®ç å€¼
  89   1        Key_Down = Key_Val & (Key_Old ^ Key_Val); // æ•æ‰æŒ‰é”®ä¸‹é™æ²¿
  90   1        Key_Up = ~Key_Val & (Key_Old ^ Key_Val);  // æ•æ‰æŒ‰é”®ä¸Šé™æ²¿
  91   1        Key_Old = Key_Val;              // è¾…åŠ©æ‰«æå˜é‡
  92   1      
  93   1        /*åˆå§‹ç•Œé¢æŒ‰é”® å¯†ç è¾“å…¥*/
  94   1        if (Seg_Disp_Mode == 0 && Pass_Input_Index < 8)
  95   1        {
  96   2          uchar input_data;
  97   2          input_data = key_to_num(Key_Down);
  98   2          // æœ‰æ•ˆè¾“å…¥
  99   2          if (input_data < 100)
 100   2          {
 101   3            Pass_Input[Pass_Input_Index] = input_data;
 102   3            Pass_Input_Index++;
 103   3          }
 104   2        }
 105   1        if (Seg_Disp_Mode == 0)
 106   1        {
 107   2          // é•¿æŒ‰ è·³è¿‡å¯†ç è¾“å…¥
 108   2          if (Key_Down == 5)
 109   2            Key_Flag = 1;
 110   2          if (Timer_3000Ms >= 3000) // åˆ¤å®šä¸ºé•¿æŒ‰
 111   2          {
 112   3            if (Key_Old == 5)
 113   3              Seg_Disp_Mode = 1; // è¿›å…¥ä¸»ç•Œé¢
 114   3            if (Key_Up == 5)
 115   3            {
 116   4              Timer_3000Ms = Key_Flag = 0;
C51 COMPILER V9.59.0.0   MAIN                                                              01/27/2024 21:35:14 PAGE 3   

 117   4            }
 118   3          }
 119   2          else
 120   2          {
 121   3            if (Key_Up == 5)
 122   3              Timer_3000Ms = Key_Flag = 0;
 123   3          }
 124   2          switch (Key_Down)
 125   2          {
 126   3          case 7:                        // ç¡®è®¤
 127   3            if (Pass_Input_Index == 8 && Seg_Disp_Mode == 0) // å¯†ç è¾“å®Œ
 128   3            {
 129   4              i = 0;
 130   4              while (Pass_Input[i] == Pass_Word[i]) // å¾ªç¯åˆ¤æ–­
 131   4              {
 132   5                i++;
 133   5                if (i == 8)
 134   5                  break; // é˜²æ­¢å¾ªç¯è¶Šç•Œåˆ¤æ–­
 135   5              }
 136   4              if (i == 8) // å¯†ç è¾“å…¥æ­£ç¡®
 137   4              {
 138   5                Seg_Disp_Mode = 1; // è¿›å…¥ä¸»ç•Œé¢
 139   5                Pass_Input_Index = 0;
 140   5                Beep(0);
 141   5              }
 142   4              else
 143   4              {
 144   5                Pass_Input_Index = 0;
 145   5                for (i = 0; i < 8; i++)
 146   5                  Pass_Input[i] = 11; // è¾“å…¥å†…å®¹æ¸…ç©º
 147   5                Beep(1);
 148   5              }
 149   4            }
 150   3            break;
 151   3          case 6: // åˆ é™¤
 152   3            if (Pass_Input_Index != 0)
 153   3            {
 154   4              Pass_Input_Index--;
 155   4              Seg_Buf[7 - Pass_Input_Index] = 11;
 156   4            }
 157   3            break;
 158   3          }
 159   2        }
 160   1        /*ç³»ç»Ÿä¸»ç•Œé¢æŒ‰é”®*/
 161   1        if ((Seg_Disp_Mode == 1 || Seg_Disp_Mode == 2) && (Uart_Enable_Flag == 0)) // æ—¶é’Ÿ è¶…å£°æ³¢æ¸©åº¦
 162   1        {
 163   2          // é•¿æŒ‰ä¿¡æ¯æ˜¾ç¤ºæŒ‰é”®å¯è¿›å…¥ä¿¡æ¯æ˜¾ç¤ºç•Œé¢ æ¾æ‰‹åè¿” å›æ—¶é’Ÿæ˜¾ç¤ºç•Œé¢
 164   2          if (Key_Down == 7)
 165   2            Key_Flag1 = 1;
 166   2          if (Timer_2000Ms > 2000) // åˆ¤å®šä¸ºé•¿æŒ‰
 167   2          {
 168   3            if (Key_Old == 7)
 169   3              Seg_Disp_Mode = 2;
 170   3            if (Key_Up == 7) // æ•æ‰åˆ°ä¸Šå‡æ²¿
 171   3            {
 172   4              Seg_Disp_Mode = 1;
 173   4              Timer_2000Ms = Key_Flag1 = 0; // å¤ä½ï¼Œä¾¿äºä¸‹æ¬¡
 174   4            }
 175   3          }
 176   2          else
 177   2          {
 178   3            if (Key_Up == 7)          // æ•æ‰åˆ°ä¸Šå‡æ²¿
C51 COMPILER V9.59.0.0   MAIN                                                              01/27/2024 21:35:14 PAGE 4   

 179   3              Timer_2000Ms = Key_Flag1 = 0; // å¤ä½ï¼Œä¾¿äºä¸‹æ¬¡
 180   3          }
 181   2      
 182   2          switch (Key_Down)
 183   2          {
 184   3          case 11: // ä¸²å£å¼€
 185   3            Uart_Enable_Flag = 1;
 186   3            break;
 187   3          case 6: // æ—¶é’Ÿè®¾ç½®ç•Œé¢
 188   3            for (i = 0; i < 3; i++)
 189   3            {
 190   4              Clock_Set[i * 2] = Clock_Crl[i] / 10;
 191   4              Clock_Set[i * 2 + 1] = Clock_Crl[i] % 10;
 192   4            }
 193   3            Seg_Disp_Mode = 3;
 194   3            break;
 195   3          case 5: // é—¹é’Ÿè®¾ç½®
 196   3            Seg_Disp_Mode = 4;
 197   3            break;
 198   3          case 4: // é—¹é’Ÿä½¿èƒ½
 199   3            Alarm_Enable_Flag = 1;
 200   3            break;
 201   3          }
 202   2        }
 203   1      
 204   1        /*æ—¶é’Ÿè®¾ç½®é—¹é’Ÿè®¾ç½®æŒ‰é”®*/
 205   1        if ((Seg_Disp_Mode == 3 || Seg_Disp_Mode == 4) && (Uart_Enable_Flag == 0))
 206   1        {
 207   2          switch (Key_Down)
 208   2          {
 209   3          case 11: // å°æ—¶è®¾ç½®
 210   3            Key_Input_Flag = 0;
 211   3            Clock_Set_Index = 0;
 212   3            break;
 213   3          case 15: // åˆ†é’Ÿè®¾ç½®
 214   3            Key_Input_Flag = 2;
 215   3            Clock_Set_Index = 2;
 216   3            break;
 217   3          case 19: // ç§’é’Ÿè®¾ç½®
 218   3            Key_Input_Flag = 4;
 219   3            Clock_Set_Index = 4;
 220   3            break;
 221   3          case 7:           // ç¡®è®¤ä¿å­˜ ä¿å­˜åˆ° EEPROM å†…
 222   3            if (Seg_Disp_Mode == 3) // æ—¶é’Ÿ
 223   3            {
 224   4              Clock[0] = (Clock_Set[0] * 10 + Clock_Set[1]);
 225   4              Clock[1] = (Clock_Set[2] * 10 + Clock_Set[3]);
 226   4              Clock[2] = (Clock_Set[4] * 10 + Clock_Set[5]);
 227   4              if (Clock[0] < 23 && Clock[1] < 59 && Clock[2] < 59) // æ•°æ®åˆç†
 228   4              {
 229   5                Set_Rtc(Clock); // ä¿å­˜
 230   5                E2PROM_Read(Clock, 8, 3);
 231   5                Seg_Disp_Mode = 1;
 232   5              }
 233   4            }
 234   3            if (Seg_Disp_Mode == 4) // é—¹é’Ÿ
 235   3            {
 236   4              E2PROM_Alarm[0] = (Alarm_Set[0] * 10 + Alarm_Set[1]);
 237   4              E2PROM_Alarm[1] = (Alarm_Set[2] * 10 + Alarm_Set[3]);
 238   4              E2PROM_Alarm[2] = (Alarm_Set[4] * 10 + Alarm_Set[5]);
 239   4              if (E2PROM_Alarm[0] < 23 && E2PROM_Alarm[1] < 59 && E2PROM_Alarm[2] < 59) // æ•°æ®åˆç†
 240   4              {
C51 COMPILER V9.59.0.0   MAIN                                                              01/27/2024 21:35:14 PAGE 5   

 241   5                E2PROM_Read(E2PROM_Alarm, 0, 3);
 242   5                Seg_Disp_Mode = 1;
 243   5              }
 244   4            }
 245   3            break;
 246   3          case 6: // å–æ¶ˆä¿å­˜
 247   3            if (Seg_Disp_Mode == 3)
 248   3            {
 249   4              Set_Rtc(Clock_Crl); // ä¿å­˜åŸæ¥å€¼
 250   4            }
 251   3            if (Seg_Disp_Mode == 4)
 252   3            {
 253   4              E2PROM_Alarm[0] = E2PROM_Alarm[1] = E2PROM_Alarm[2] = 0;
 254   4            }
 255   3            break;
 256   3          case 5: // ä¸²å£
 257   3            Uart_Enable_Flag = 1;
 258   3            break;
 259   3          }
 260   2          if (Clock_Set_Index < (Key_Input_Flag + 2)) // è¾“å…¥ä¸¤ä¸ªä¹‹åä¸èƒ½å†è¾“
 261   2          {
 262   3            uchar input_data;
 263   3            input_data = key_to_num(Key_Down);
 264   3            switch (Key_Down) // æ—¶é—´è¾“å…¥
 265   3            {
 266   4            case 4:
 267   4              if (Seg_Disp_Mode == 3)
 268   4                Clock_Set[Clock_Set_Index] = 0;
 269   4              else if (Seg_Disp_Mode == 4)
 270   4                Alarm_Set[Clock_Set_Index] = 0;
 271   4              Clock_Set_Index++;
 272   4              break;
 273   4            case 8:
 274   4              if (Seg_Disp_Mode == 3)
 275   4                Clock_Set[Clock_Set_Index] = 1;
 276   4              else if (Seg_Disp_Mode == 4)
 277   4                Alarm_Set[Clock_Set_Index] = 1;
 278   4              Clock_Set_Index++;
 279   4              break;
 280   4            case 12:
 281   4              if (Seg_Disp_Mode == 3)
 282   4                Clock_Set[Clock_Set_Index] = 2;
 283   4              else if (Seg_Disp_Mode == 4)
 284   4                Alarm_Set[Clock_Set_Index] = 2;
 285   4              Clock_Set_Index++;
 286   4              break;
 287   4            case 16:
 288   4              if (Seg_Disp_Mode == 3)
 289   4                Clock_Set[Clock_Set_Index] = 3;
 290   4              else if (Seg_Disp_Mode == 4)
 291   4                Alarm_Set[Clock_Set_Index] = 3;
 292   4              Clock_Set_Index++;
 293   4              break;
 294   4            case 9:
 295   4              if (Seg_Disp_Mode == 3)
 296   4                Clock_Set[Clock_Set_Index] = 4;
 297   4              else if (Seg_Disp_Mode == 4)
 298   4                Alarm_Set[Clock_Set_Index] = 4;
 299   4              Clock_Set_Index++;
 300   4              break;
 301   4            case 13:
 302   4              if (Seg_Disp_Mode == 3)
C51 COMPILER V9.59.0.0   MAIN                                                              01/27/2024 21:35:14 PAGE 6   

 303   4                Clock_Set[Clock_Set_Index] = 5;
 304   4              else if (Seg_Disp_Mode == 4)
 305   4                Alarm_Set[Clock_Set_Index] = 5;
 306   4              Clock_Set_Index++;
 307   4              break;
 308   4            case 17:
 309   4              if (Seg_Disp_Mode == 3)
 310   4                Clock_Set[Clock_Set_Index] = 6;
 311   4              else if (Seg_Disp_Mode == 4)
 312   4                Alarm_Set[Clock_Set_Index] = 6;
 313   4              Clock_Set_Index++;
 314   4              break;
 315   4            case 10:
 316   4              if (Seg_Disp_Mode == 3)
 317   4                Clock_Set[Clock_Set_Index] = 7;
 318   4              else if (Seg_Disp_Mode == 4)
 319   4                Alarm_Set[Clock_Set_Index] = 7;
 320   4              Clock_Set_Index++;
 321   4              break;
 322   4            case 14:
 323   4              if (Seg_Disp_Mode == 3)
 324   4                Clock_Set[Clock_Set_Index] = 8;
 325   4              else if (Seg_Disp_Mode == 4)
 326   4                Alarm_Set[Clock_Set_Index] = 8;
 327   4              Clock_Set_Index++;
 328   4              break;
 329   4            case 18:
 330   4              if (Seg_Disp_Mode == 3)
 331   4                Clock_Set[Clock_Set_Index] = 9;
 332   4              else if (Seg_Disp_Mode == 4)
 333   4                Alarm_Set[Clock_Set_Index] = 9;
 334   4              Clock_Set_Index++;
 335   4              break;
 336   4            }
 337   3          }
 338   2        }
 339   1      }
 340          
 341          /* ä¿¡æ¯å¤„ç†å‡½æ•° */
 342          void Seg_Proc()
 343          {
 344   1        uchar i;
 345   1        switch (Seg_Slow_Down)
 346   1        {
 347   2        case 100: // æ—¶é’Ÿè¯»å–
 348   2          Seg_Slow_Down++;
 349   2          Read_Rtc(Clock_Crl);
 350   2          break;
 351   2        case 200: // è¶…å£°æ³¢
 352   2          Seg_Slow_Down++;
 353   2          ultrasonic = Ut_Wave_Data();
 354   2          if ((ultrasonic_Ture - ultrasonic < 10) || (ultrasonic - ultrasonic_Ture < 10))
 355   2            ultrasonic_Ture = ultrasonic;
 356   2          break;
 357   2        case 300: // AD
 358   2          Seg_Slow_Down++;
 359   2          AD_Output = Ad_Read(0x43);        // å…‰æ•ç”µé˜»
 360   2          AD_Rb2_Output = Ad_Read(0x41) / 51.0; // ç”µä½å™¨è¾“å‡º
 361   2          Da_Write(DA_Output);          // DAè¾“å‡º
 362   2          Sun_Flag = (AD_Output > 100);
 363   2          break;
 364   2        case 400: // æ¸©åº¦
C51 COMPILER V9.59.0.0   MAIN                                                              01/27/2024 21:35:14 PAGE 7   

 365   2          Seg_Slow_Down++;
 366   2          Temp = rd_temperature();
 367   2          break;
 368   2        }
 369   1      
 370   1        Seg_Point[5] = (Seg_Disp_Mode == 2);
 371   1        switch (Seg_Disp_Mode)
 372   1        {
 373   2        case 0: // ç³»ç»Ÿåˆå§‹ç•Œé¢
 374   2          if (Pass_Input_Index != 0)
 375   2          {
 376   3            for (i = 0; i < Pass_Input_Index; i++)
 377   3              Seg_Buf[7 - i] = Pass_Input[Pass_Input_Index - i - 1];
 378   3          }
 379   2          else
 380   2          {
 381   3            for (i = 0; i < 8; i++)
 382   3              Seg_Buf[i] = 11;
 383   3          }
 384   2          break;
 385   2        case 1: // ä¸»ç•Œé¢
 386   2          for (i = 0; i < 3; i++)
 387   2          {
 388   3            Seg_Buf[i * 2 + i] = Clock_Crl[i] / 10;
 389   3            Seg_Buf[i * 2 + i + 1] = Clock_Crl[i] % 10;
 390   3          }
 391   2          Seg_Buf[2] = Seg_Buf[5] = Seg_Star_Flag ? 10 : 11;
 392   2          break;
 393   2        case 2: // è¶…å£°æ³¢ å…‰ æ¸©åº¦
 394   2          Seg_Buf[0] = ultrasonic_Ture / 10;
 395   2          Seg_Buf[1] = ultrasonic_Ture % 10;
 396   2          Seg_Buf[2] = (uchar)Sun_Flag;
 397   2          Seg_Buf[3] = 11;
 398   2          Seg_Buf[4] = (uchar)Temp / 10;
 399   2          Seg_Buf[5] = (uchar)Temp % 10;
 400   2          Seg_Buf[6] = (uint)(Temp * 10) % 10;
 401   2          Seg_Buf[7] = 12;
 402   2          break;
 403   2        case 3: // æ—¶é’Ÿè®¾ç½®
 404   2          Seg_Buf[0] = Clock_Set[0];
 405   2          Seg_Buf[1] = Clock_Set[1];
 406   2          Seg_Buf[3] = Clock_Set[2];
 407   2          Seg_Buf[4] = Clock_Set[3];
 408   2          Seg_Buf[6] = Clock_Set[4];
 409   2          Seg_Buf[7] = Clock_Set[5];
 410   2      
 411   2          Seg_Buf[2] = Seg_Buf[5] = Seg_Star_Flag2 ? 10 : 11;
 412   2          break;
 413   2        case 4: // é—¹é’Ÿè®¾ç½®
 414   2          Seg_Buf[0] = Alarm_Set[0];
 415   2          Seg_Buf[1] = Alarm_Set[1];
 416   2          Seg_Buf[3] = Alarm_Set[2];
 417   2          Seg_Buf[4] = Alarm_Set[3];
 418   2          Seg_Buf[6] = Alarm_Set[4];
 419   2          Seg_Buf[7] = Alarm_Set[5];
 420   2      
 421   2          Seg_Buf[2] = Seg_Buf[5] = Seg_Star_Flag2 ? 10 : 11;
 422   2          break;
 423   2        }
 424   1      }
 425          
 426          /* å…¶ä»–æ˜¾ç¤ºå‡½æ•° */
C51 COMPILER V9.59.0.0   MAIN                                                              01/27/2024 21:35:14 PAGE 8   

 427          void Led_Proc()
 428          {
 429   1      
 430   1        ucLed[0] = (Seg_Disp_Mode == 0);
 431   1        ucLed[1] = (Seg_Disp_Mode == 1);
 432   1        ucLed[2] = (Seg_Disp_Mode == 3);
 433   1        ucLed[3] = (Seg_Disp_Mode == 4);
 434   1        ucLed[4] = (Seg_Disp_Mode == 2);
 435   1      
 436   1        Led_Lever = ((AD_Rb2_Output) * 2.0);
 437   1        // DA
 438   1        DA_Output = (Sun_Flag ? 1 : 5);
 439   1      }
 440          
 441          /*ä¸²å£*/
 442          void Uart_Sent_Proc()
 443          {
 444   1        if (Uart_Slow_Down)
 445   1          return;
 446   1        Uart_Slow_Down = 1;
 447   1        // æ¯åˆ°ä¸€ä¸ªæ•´ç‚¹åå•ç‰‡æœºå‘ä¸Šä½æœºå‘é€æŒ‡ä»¤
 448   1        if (Clock_Crl[1] == 0 && Clock_Crl[2] == 0) // æ•´ç‚¹
 449   1        {
 450   2          printf("Time = %d:%d:%d", (uint)Clock_Crl[0], (uint)Clock_Crl[1], (uint)Clock_Crl[2]);
 451   2        }
 452   1      
 453   1        if (Seg_Disp_Mode == 1) // æ—¶é’Ÿæ˜¾ç¤ºç•Œé¢
 454   1        {
 455   2          if (Timer_Count == 2) // åœ¨æ—¶é’Ÿæ˜¾ç¤ºç•Œé¢æ—¶æ¯é—´éš”ä¸‰ç§’å•ç‰‡æœºå‘ä¸Šä½æœºå‘é€æŒ‡ä»¤
 456   2            printf("%d:%d-%dCM_%dC", (uint)Clock_Crl[0], (uint)Clock_Crl[1], (uint)ultrasonic_Ture, (uint)Temp);
 457   2        }
 458   1      }
 459          
 460          /*ä¸²å£å¤„ç†å‡½æ•°*/
 461          void Uart_Proc()
 462          {
 463   1        uchar a; // Forå¾ªç¯
 464   1        uchar i; // whileå¾ªç¯
 465   1        if (Uart_Recv_Index == 0)
 466   1          return;
 467   1        if (Syt_Flag >= 10)
 468   1        {
 469   2          Syt_Flag = Time_Syt_Flag = 0; // å¤ä½
 470   2          if (Uart_Enable_Flag)     // ä¸²å£å¼€å§‹ä½¿èƒ½
 471   2          {
 472   3            if ((Seg_Disp_Mode == 1 || Seg_Disp_Mode == 2))
 473   3            {
 474   4              if (Uart_Recv_Index == 4) // ä¸»ç•Œé¢ä¸²å£åŠŸèƒ½
 475   4              {
 476   5                if (Uart_Recv[0] == 'D' && Uart_Recv[1] == 'I' && Uart_Recv[2] == 'S' && Uart_Recv[3] == 'P') // ä¿¡æ
             -¯æ˜¾ç¤º
 477   5                {
 478   6                  Seg_Disp_Mode = 2; // ä¿¡æ¯æ˜¾ç¤ºç•Œé¢
 479   6                }
 480   5                if (Uart_Recv[0] == 'C' && Uart_Recv[1] == 'K' && Uart_Recv[2] == 'G' && Uart_Recv[3] == 'B') // ä¸²å
             -£å…³
 481   5                {
 482   6                  Uart_Enable_Flag = 0; // å…³é—­ä¸²å£åŠŸèƒ½
 483   6                  Seg_Disp_Mode = 1;
 484   6                }
 485   5                if (Uart_Recv[0] == 'S' && Uart_Recv[1] == 'Z' && Uart_Recv[2] == 'S' && Uart_Recv[3] == 'Z') // æ—¶é
             -’Ÿè®¾ç½®
C51 COMPILER V9.59.0.0   MAIN                                                              01/27/2024 21:35:14 PAGE 9   

 486   5                {
 487   6                  Seg_Disp_Mode = 3; // æ—¶é’Ÿè®¾ç½®ç•Œé¢
 488   6                }
 489   5                if (Uart_Recv[0] == 'N' && Uart_Recv[1] == 'Z' && Uart_Recv[2] == 'S' && Uart_Recv[3] == 'Z') // é—¹é
             -’Ÿè®¾ç½®
 490   5                {
 491   6                  Seg_Disp_Mode = 4; // é—¹é’Ÿè®¾ç½®ç•Œé¢
 492   6                }
 493   5                if (Uart_Recv[0] == 'N' && Uart_Recv[1] == 'Z' && Uart_Recv[2] == 'K' && Uart_Recv[3] == 'G') // é—¹é
             -’Ÿè®¾ç½®
 494   5                {
 495   6                  Alarm_Enable_Flag = 1; // é—¹é’Ÿä½¿èƒ½
 496   6                }
 497   5              }
 498   4            }
 499   3            if ((Seg_Disp_Mode == 3 || Seg_Disp_Mode == 4))
 500   3            {
 501   4              if (Uart_Recv_Index == 6) // æ—¶é’Ÿé—¹é’Ÿè®¾ç½®
 502   4              {
 503   5                // å°æ—¶è®¾ç½®ï¼šHSetXX
 504   5                if (Uart_Recv[0] == 'H' && Uart_Recv[1] == 'S' && Uart_Recv[2] == 'e' && Uart_Recv[3] == 't') // é—¹é
             -’Ÿè®¾ç½®
 505   5                {
 506   6                  if (((Uart_Recv[4] >= '0') && (Uart_Recv[4] <= '9')) && ((Uart_Recv[5] >= '0') && (Uart_Recv[5] <= '
             -9'))) // 0-9
 507   6                  {
 508   7                    if (Seg_Disp_Mode == 3) // æ—¶é’Ÿè®¾ç½®
 509   7                    {
 510   8                      Clock_Set[0] = Uart_Recv[4] - 48;
 511   8                      Clock_Set[1] = Uart_Recv[5] - 48;
 512   8                    }
 513   7                    else // é—¹é’Ÿè®¾ç½®
 514   7                    {
 515   8                      Alarm_Set[0] = Uart_Recv[4] - 48;
 516   8                      Alarm_Set[1] = Uart_Recv[5] - 48;
 517   8                    }
 518   7                  }
 519   6                }
 520   5                // åˆ†é’Ÿè®¾ç½®ï¼šMSetXX
 521   5                if (Uart_Recv[0] == 'M' && Uart_Recv[1] == 'S' && Uart_Recv[2] == 'e' && Uart_Recv[3] == 't') // é—¹é
             -’Ÿè®¾ç½®
 522   5                {
 523   6                  if (((Uart_Recv[4] >= '0') && (Uart_Recv[4] <= '9')) && ((Uart_Recv[5] >= '0') && (Uart_Recv[5] <= '
             -9'))) // 0-9
 524   6                  {
 525   7                    if (Seg_Disp_Mode == 3)
 526   7                    {
 527   8                      Clock_Set[2] = Uart_Recv[4] - 48;
 528   8                      Clock_Set[3] = Uart_Recv[5] - 48;
 529   8                    }
 530   7                    else
 531   7                    {
 532   8                      Alarm_Set[2] = Uart_Recv[4] - 48;
 533   8                      Alarm_Set[3] = Uart_Recv[5] - 48;
 534   8                    }
 535   7                  }
 536   6                }
 537   5                // ç§’é’Ÿè®¾ç½®ï¼šSSetXX
 538   5                if (Uart_Recv[0] == 'S' && Uart_Recv[1] == 'S' && Uart_Recv[2] == 'e' && Uart_Recv[3] == 't') // é—¹é
             -’Ÿè®¾ç½®
 539   5                {
 540   6                  if (((Uart_Recv[4] >= '0') && (Uart_Recv[4] <= '9')) && ((Uart_Recv[5] >= '0') && (Uart_Recv[5] <= '
C51 COMPILER V9.59.0.0   MAIN                                                              01/27/2024 21:35:14 PAGE 10  

             -9'))) // 0-9
 541   6                  {
 542   7                    if (Seg_Disp_Mode == 3)
 543   7                    {
 544   8                      Clock_Set[4] = Uart_Recv[4] - 48;
 545   8                      Clock_Set[5] = Uart_Recv[5] - 48;
 546   8                    }
 547   7                    else
 548   7                    {
 549   8                      Alarm_Set[4] = Uart_Recv[4] - 48;
 550   8                      Alarm_Set[5] = Uart_Recv[5] - 48;
 551   8                    }
 552   7                  }
 553   6                }
 554   5              }
 555   4              if (Uart_Recv_Index == 4) // å…³é—­ä¸²å£
 556   4              {
 557   5                if (Uart_Recv[0] == 'C' && Uart_Recv[1] == 'K' && Uart_Recv[2] == 'G' && Uart_Recv[3] == 'B') // ä¸²å
             -£å…³
 558   5                  Uart_Enable_Flag = 0;
 559   5              }
 560   4            }
 561   3          }
 562   2          if (Seg_Disp_Mode == 1) // åœ¨æ—¶é’Ÿæ˜¾ç¤ºç•Œé¢æ—¶ä¸Šä½æœºå¯å‘é€ä¿®æ”¹å¯†ç æŒ‡ä»¤
 563   2          {
 564   3            if (Uart_Recv_Index == 10)
 565   3            {
 566   4              if (Uart_Recv[0] == 'X' && Uart_Recv[1] == 'G')
 567   4              {
 568   5                i = 2;
 569   5                while (((Uart_Recv[i] >= '0') && (Uart_Recv[4] <= '9')))
 570   5                {
 571   6                  i++;
 572   6                  if (i == 8)
 573   6                    break;
 574   6                }
 575   5                if (i == 8)
 576   5                {
 577   6                  for (a = 0; a < 8; a++)
 578   6                  {
 579   7                    Pass_Word[a] = Uart_Recv[a + 2] - 48;
 580   7                    Seg_Disp_Mode = 0;
 581   7                  }
 582   6                }
 583   5              }
 584   4            }
 585   3          }
 586   2          memset(Uart_Recv, 0, Uart_Recv_Index);
 587   2          Uart_Recv_Index = 0;
 588   2        }
 589   1      }
 590          /*å®šæ—¶å™¨1ä¸­æ–­åˆå§‹åŒ–å‡½æ•°*/
 591          void Timer1_Init(void) // 125å¾®ç§’@12.000MHz
 592          {
 593   1        AUXR &= 0xBF; // å®šæ—¶å™¨æ—¶é’Ÿ12Tæ¨¡å¼
 594   1        TMOD &= 0x0F; // è®¾ç½®å®šæ—¶å™¨æ¨¡å¼
 595   1        TL1 = 0x83;   // è®¾ç½®å®šæ—¶åˆå§‹å€¼
 596   1        TH1 = 0xFF;   // è®¾ç½®å®šæ—¶åˆå§‹å€¼
 597   1        TF1 = 0;    // æ¸…é™¤TF1æ ‡å¿—
 598   1        TR1 = 1;    // å®šæ—¶å™¨1å¼€å§‹è®¡æ—¶
 599   1        ET1 = 1;    // å®šæ—¶å™¨ä¸­æ–­1æ‰“å¼€
 600   1      }
C51 COMPILER V9.59.0.0   MAIN                                                              01/27/2024 21:35:14 PAGE 11  

 601          
 602          /* å®šæ—¶å™¨0ä¸­æ–­åˆå§‹åŒ–å‡½æ•° */
 603          void Timer0Init(void) // 1æ¯«ç§’@12.000MHz
 604          {
 605   1        AUXR &= 0x7F; // å®šæ—¶å™¨æ—¶é’Ÿ12Tæ¨¡å¼
 606   1        TMOD &= 0xF0; // è®¾ç½®å®šæ—¶å™¨æ¨¡å¼
 607   1        TL0 = 0x18;   // è®¾ç½®å®šæ—¶åˆå§‹å€¼
 608   1        TH0 = 0xFC;   // è®¾ç½®å®šæ—¶åˆå§‹å€¼
 609   1        TF0 = 0;    // æ¸…é™¤TF0æ ‡å¿—
 610   1        TR0 = 1;    // å®šæ—¶å™¨0å¼€å§‹è®¡æ—¶
 611   1        ET0 = 1;    // å®šæ—¶å™¨ä¸­æ–­0æ‰“å¼€
 612   1        EA = 1;     // æ€»ä¸­æ–­æ‰“å¼€
 613   1      }
 614          
 615          /* å®šæ—¶å™¨0ä¸­æ–­æœåŠ¡å‡½æ•° */
 616          void Timer0Server() interrupt 1
 617          {
 618   1        if (++Uart_Slow_Down == 1000)
 619   1        {
 620   2          Uart_Slow_Down = 0;
 621   2          if (++Timer_Count == 3)
 622   2            Timer_Count = 0;
 623   2        }
 624   1        if (++Key_Slow_Down == 10)
 625   1          Key_Slow_Down = 0; // é”®ç›˜å‡é€Ÿä¸“ç”¨
 626   1        if (++Seg_Slow_Down == 500)
 627   1          Seg_Slow_Down = 0; // æ•°ç ç®¡å‡é€Ÿä¸“ç”¨
 628   1        if (++Seg_Pos == 8)
 629   1          Seg_Pos = 0; // æ•°ç ç®¡æ˜¾ç¤ºä¸“ç”¨
 630   1        Seg_Disp(Seg_Pos, Seg_Buf[Seg_Pos], Seg_Point[Seg_Pos]);
 631   1      
 632   1        if (Key_Flag == 1)
 633   1        {
 634   2          if (++Timer_3000Ms == 4000) // é•¿æŒ‰
 635   2          {
 636   3            Timer_3000Ms = 4000;
 637   3          }
 638   2        }
 639   1      
 640   1        if (++Timer_500Ms == 500) // æ—¶é—´é—´éš”ç¬¦é—ªçƒ
 641   1        {
 642   2          Timer_500Ms = 0;
 643   2          Seg_Star_Flag ^= 1;
 644   2        }
 645   1      
 646   1        if (++Timer_700Ms == 700) // æ—¶é—´é—¹é’Ÿè®¾ç½®é—´éš”ç¬¦
 647   1        {
 648   2          Timer_700Ms = 0;
 649   2          Seg_Star_Flag2 ^= 1;
 650   2        }
 651   1      
 652   1        if (Key_Flag1)
 653   1        {
 654   2          if (++Timer_2000Ms == 3000) // é•¿æŒ‰
 655   2            Timer_2000Ms = 3000;
 656   2        }
 657   1      
 658   1        // ä¸²å£
 659   1        if (Time_Syt_Flag)
 660   1          Syt_Flag++;
 661   1      
 662   1        // ledäº®åº¦ç­‰çº§
C51 COMPILER V9.59.0.0   MAIN                                                              01/27/2024 21:35:14 PAGE 12  

 663   1        if (++Term_Led == 10)
 664   1          Term_Led = 0;
 665   1      }
 666          
 667          /*å®šæ—¶å™¨1æœåŠ¡å‡½æ•°*/
 668          void Timer1Server() interrupt 3
 669          {
 670   1        if (++Led_Pos == 8)
 671   1          Led_Pos = 0;
 672   1      
 673   1        if (Term_Led <= Led_Lever)
 674   1          Led_Disp(Led_Pos, ucLed[Led_Pos]);
 675   1        else
 676   1          Led_Disp(Led_Pos, 0);
 677   1      }
 678          
 679          /*ä¸²å£*/
 680          void Uart1Server() interrupt 4
 681          {
 682   1        if (RI == 1) // å¼€å§‹æ¥å—æ•°æ®
 683   1        {
 684   2          Time_Syt_Flag = 1;
 685   2          Syt_Flag = 0;
 686   2          Uart_Recv[Uart_Recv_Index] = SBUF;
 687   2          Uart_Recv_Index++;
 688   2          RI = 0;
 689   2        }
 690   1        if (Uart_Recv_Index > 10)
 691   1          Uart_Recv_Index = 0;
 692   1      }
 693          void Delay750ms() //@12.000MHz
 694          {
 695   1        unsigned char i, j, k;
 696   1      
 697   1        _nop_();
 698   1        _nop_();
 699   1        i = 35;
 700   1        j = 51;
 701   1        k = 182;
 702   1        do
 703   1        {
 704   2          do
 705   2          {
 706   3            while (--k)
 707   3              ;
 708   3          } while (--j);
 709   2        } while (--i);
 710   1      }
 711          
 712          /* Main */
 713          void main()
 714          {
 715   1        rd_temperature();
 716   1        Delay750ms(); // å»¶æ—¶ç¡®ä¿ä¸Šç”µåä¸‹æ¬¡è¯»å–ä¸æ˜¯85
 717   1        System_Init();
 718   1        Timer0Init();
 719   1        Set_Rtc(Clock_Crl);
 720   1        UartInit();
 721   1        E2PROM_Write(E2PROM_Alarm, 0, 3);
 722   1        Alarm[0] = E2PROM_Alarm[0];
 723   1        Alarm[1] = E2PROM_Alarm[1];
 724   1        Alarm[2] = E2PROM_Alarm[2];
C51 COMPILER V9.59.0.0   MAIN                                                              01/27/2024 21:35:14 PAGE 13  

 725   1        E2PROM_Write(Clock, 8, 3);
 726   1        Clock_Crl[0] = Clock[0];
 727   1        Clock_Crl[1] = Clock[1];
 728   1        Clock_Crl[2] = Clock[2];
 729   1      
 730   1        Timer1_Init();
 731   1        while (1)
 732   1        {
 733   2          Uart_Sent_Proc();
 734   2          Key_Proc();
 735   2          Seg_Proc();
 736   2          Led_Proc();
 737   2          Uart_Proc();
 738   2        }
 739   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   3110    ----
   CONSTANT SIZE    =     31    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     87       3
   IDATA SIZE       =     34    ----
   BIT SIZE         =      8    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
