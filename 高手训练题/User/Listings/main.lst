C51 COMPILER V9.59.0.0   MAIN                                                              01/26/2024 21:15:45 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Driver) DEBUG OBJECTEXTEND PRI
                    -NT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "main.h"
   2          /* 变量声明区 */
   3          uchar Key_Slow_Down;                 // 按键减速专用变量
   4          uchar Seg_Buf[8] = {10, 10, 10, 10, 10, 10, 10, 10}; // 数码管显示数据存放数组
   5          uchar Seg_Point[8] = {0, 0, 0, 0, 0, 0, 0, 0};     // 数码管小数点数据存放数组
   6          uchar Seg_Pos;                     // 数码管扫描专用变量
   7          uint Seg_Slow_Down;                  // 数码管减速专用变量
   8          uchar ucLed[8] = {0, 0, 0, 0, 0, 0, 0, 0};       // Led显示数据存放数组
   9          uchar Uart_Slow_Down;                // 串口减速专用变量
  10          uchar Uart_Recv[10];                 // 串口接收数据储存数组 默认10个字节 若接收数据较长 可更改最大字节数
  11          uchar Uart_Recv_Index;                 // 串口接收数组指针
  12          uchar Uart_Send[10];                 // 串口接收数据储存数组 默认10个字节 若发送数据较长 可更改最大字节数
  13          
  14          /* 界面 */
  15          uchar Seg_show_mode; // 0 初始界面 1时钟界面 2信息显示界面 3 时钟设置界面 4闹钟设置界面
  16          
  17          /*密码*/
  18          idata uchar Password_set[8] = {1, 2, 3, 4, 5, 6, 7, 8};       // 初始的默认密码
  19          idata uchar Password_input[8] = {11, 11, 11, 11, 11, 11, 11, 11}; // 密码，最初为没有输入的状态
  20          uchar Password_input_index;                     // 密码输入的指针
  21          bit wring_flag;                           // 密码错误标志
  22          bit ring_flag;                            // 蜂鸣器
  23          
  24          /* 时间 */
  25          uchar ucRtc[3] = {0x23, 0x59, 0x55};
  26          uint time_1s;
  27          uint time_500ms;
  28          uint time_700ms;
  29          bit skip_flag;        // 跳过的标志
  30          bit time_interval_flag;   // 时间显示中间间隔符闪烁
  31          bit time_set_interval_flag; // 设置界面时间中间间隔闪烁
  32          bit massage_show_flag;    // 0显示时间，1显示信息
  33          bit massage_show_time_flag; // 开启长按时间->信息跳转计时
  34          bit alarm_open;       // 闹钟开启
  35          
  36          // LED和Seg初始化
  37          void Init_Seg_Led()
  38          {
  39   1        uchar i;
  40   1        for (i = 0; i < 8; i++)
  41   1        {
  42   2          Seg_Buf[i] = 0;
  43   2          Seg_Point[i] = 0;
  44   2          ucLed[i] = 0;
  45   2        }
  46   1      }
  47          /* 键盘处理函数 */
  48          void Key_Proc()
  49          {
  50   1        static uchar Key_Val, Key_Down, Key_Old, Key_Up; // 按键专用变量
  51   1        uchar i, j;
  52   1        if (Key_Slow_Down)
  53   1          return;
  54   1        Key_Slow_Down = 1; // 键盘减速程序
C51 COMPILER V9.59.0.0   MAIN                                                              01/26/2024 21:15:45 PAGE 2   

  55   1      
  56   1        Key_Val = Key_Read();           // 实时读取键码值
  57   1        Key_Down = Key_Val & (Key_Old ^ Key_Val); // 捕捉按键下降沿
  58   1        Key_Up = ~Key_Val & (Key_Old ^ Key_Val);  // 捕捉按键上降沿
  59   1        Key_Old = Key_Val;              // 辅助扫描变量
  60   1        switch (Seg_show_mode)
  61   1        {
  62   2        case 0: // 登录界面
  63   2          if (Password_input_index < 8 && Key_Down)
  64   2          {
  65   3            // 0 1 2 3 4 5 6 7 8 9
  66   3            uchar key_mapping[] = {4, 8, 12, 16, 9, 13, 17, 10, 14, 18};
  67   3            for (i = 0; i < 10; i++)
  68   3            {
  69   4              if (Key_Down == key_mapping[i])
  70   4              {
  71   5                break;
  72   5              }
  73   4            }
  74   3            // 按下的不是最后一个，那么就是其他的按键，这里不做处理
  75   3            if (i == 10 && Key_Down != 18)
  76   3            {
  77   4            }
  78   3            else
  79   3            {
  80   4              Password_input[Password_input_index] = i;
  81   4              Password_input_index++;
  82   4            }
  83   3          }
  84   2          // 按下确认
  85   2          if (Key_Down == 7)
  86   2          {
  87   3            for (i = 0; i < 8; i++)
  88   3            {
  89   4              if (Password_set[i] != Password_input[i])
  90   4              {
  91   5                // 报警
  92   5                wring_flag = 1;
  93   5                ring_flag = 1;
  94   5                // 清空输入内容
  95   5                for (j = 0; j < 8; j++)
  96   5                {
  97   6                  Password_input[j] = 11;
  98   6                }
  99   5                break;
 100   5              }
 101   4            }
 102   3            if (i == 8)
 103   3            {
 104   4              // 密码正确
 105   4              wring_flag = 0;
 106   4              ring_flag = 0;
 107   4              Seg_show_mode++; // 到达下一个界面
 108   4            }
 109   3          }
 110   2          // 按下删除
 111   2          if (Key_Down == 6)
 112   2          {
 113   3            if (Password_input_index == 8)
 114   3              Password_input_index = 7;
 115   3            Password_input[Password_input_index] = 11;
 116   3            if (Password_input_index > 0 && Password_input_index < 7)
C51 COMPILER V9.59.0.0   MAIN                                                              01/26/2024 21:15:45 PAGE 3   

 117   3              Password_input_index--;
 118   3          }
 119   2          // 跳过密码
 120   2          if (Key_Old == 5)
 121   2          {
 122   3            skip_flag = 1;
 123   3            if (time_1s == 1000)
 124   3            {
 125   4              Seg_show_mode++; // 跳转到下一个界面
 126   4            }
 127   3          }
 128   2          else
 129   2          {
 130   3            time_1s = skip_flag = 0; // 重置长按时间
 131   3          }
 132   2          break;
 133   2      
 134   2        case 1:
 135   2          /* 主界面 */
 136   2          // 信息显示按钮,长按1s进入信息显示界面，松手回到时钟界面
 137   2          if (Key_Old == 7)
 138   2          {
 139   3            massage_show_time_flag = 1;
 140   3          }
 141   2          if (Key_Up == 7)
 142   2          {
 143   3            Init_Seg_Led();
 144   3            massage_show_time_flag = massage_show_flag = 0;
 145   3          }
 146   2          // 开启/关闭闹钟
 147   2          if (Key_Down == 4)
 148   2          {
 149   3            alarm_open = ~alarm_open;
 150   3          }
 151   2          // 进入设置界面
 152   2          if (Key_Down == 6)
 153   2          {
 154   3            Seg_show_mode++;
 155   3            Init_Seg_Led();
 156   3          }
 157   2          break;
 158   2        case 2:
 159   2          /* 时钟设置界面 */
 160   2          switch (Key_Down)
 161   2          {
 162   3          case 11:
 163   3            /* 设置小时 */
 164   3      
 165   3            break;
 166   3      
 167   3          default:
 168   3            break;
 169   3          }
 170   2          break;
 171   2        }
 172   1      }
 173          
 174          /* 信息处理函数 */
 175          void Seg_Proc()
 176          {
 177   1        uchar i;
 178   1        if (Seg_Slow_Down)
C51 COMPILER V9.59.0.0   MAIN                                                              01/26/2024 21:15:45 PAGE 4   

 179   1          return;
 180   1        Seg_Slow_Down = 1; // 数码管减速程序
 181   1        switch (Seg_show_mode)
 182   1        {
 183   2        case 0:
 184   2          /* 密码输入 */
 185   2          if (Password_input_index)
 186   2          {
 187   3            for (i = 0; i < Password_input_index; i++)
 188   3            {
 189   4              Seg_Buf[7 - i] = Password_input[Password_input_index - i - 1];
 190   4            }
 191   3            for (i = Password_input_index; i < 8; i++)
 192   3            {
 193   4              Seg_Buf[7 - i] = 11;
 194   4            }
 195   3          }
 196   2          else
 197   2          {
 198   3            // 没有密码输入
 199   3            for (i = 0; i < 8; i++)
 200   3            {
 201   4              Seg_Buf[i] = 11;
 202   4            }
 203   3          }
 204   2          break;
 205   2        case 1:
 206   2          if (massage_show_flag)
 207   2          {
 208   3            uchar dis_value;
 209   3            uint temperature_value;
 210   3            uchar light_value;
 211   3            dis_value = Ut_Wave_Data() % 100;
 212   3            temperature_value = rd_temperature() * 10;
 213   3            light_value = Ad_Read(0x41);
 214   3            Seg_Buf[0] = dis_value / 10;
 215   3            Seg_Buf[1] = dis_value % 10;
 216   3            Seg_Buf[2] = (light_value > 50) ? 1 : 0;
 217   3            Seg_Buf[3] = 11;
 218   3            Seg_Buf[4] = temperature_value / 100;
 219   3            Seg_Buf[5] = (temperature_value % 100) / 10;
 220   3            Seg_Buf[6] = temperature_value % 10;
 221   3            Seg_Point[5] = 1;
 222   3            Seg_Buf[7] = 12; // C
 223   3          }
 224   2          else
 225   2          {
 226   3            Read_Rtc(ucRtc);
 227   3            Seg_Buf[0] = ucRtc[0] / 16;
 228   3            Seg_Buf[1] = ucRtc[0] % 16;
 229   3            Seg_Buf[2] = Seg_Buf[5] = (time_interval_flag) ? 11 : 10;
 230   3            Seg_Buf[3] = ucRtc[1] / 16;
 231   3            Seg_Buf[4] = ucRtc[1] % 16;
 232   3            Seg_Buf[6] = ucRtc[2] / 16;
 233   3            Seg_Buf[7] = ucRtc[2] % 16;
 234   3          }
 235   2          break;
 236   2        case 2: // 时钟/闹钟设置
 237   2      
 238   2          break;
 239   2        }
 240   1      }
C51 COMPILER V9.59.0.0   MAIN                                                              01/26/2024 21:15:45 PAGE 5   

 241          
 242          /* 其他显示函数 */
 243          void Led_Proc()
 244          {
 245   1        Beep(ring_flag);
 246   1      }
 247          
 248          /* 串口处理函数 */
 249          void Uart_Proc()
 250          {
 251   1        if (Uart_Slow_Down)
 252   1          return;
 253   1        Uart_Slow_Down = 1; // 串口减速程序
 254   1      }
 255          
 256          /* 定时器0中断初始化函数 */
 257          void Timer0Init(void) // 1毫秒@12.000MHz
 258          {
 259   1        AUXR &= 0x7F; // 定时器时钟12T模式
 260   1        TMOD &= 0xF0; // 设置定时器模式
 261   1        TL0 = 0x18;   // 设置定时初始值
 262   1        TH0 = 0xFC;   // 设置定时初始值
 263   1        TF0 = 0;    // 清除TF0标志
 264   1        TR0 = 1;    // 定时器0开始计时
 265   1        ET0 = 1;    // 定时器中断0打开
 266   1        EA = 1;     // 总中断打开
 267   1      }
 268          
 269          /* 定时器0中断服务函数 */
 270          void Timer0Server() interrupt 1
 271          {
 272   1        if (++Key_Slow_Down == 10)
 273   1          Key_Slow_Down = 0; // 键盘减速专用
 274   1        if (++Seg_Slow_Down == 500)
 275   1          Seg_Slow_Down = 0; // 数码管减速专用
 276   1        if (++Uart_Slow_Down == 200)
 277   1          Uart_Slow_Down = 0; // 串口减速专用
 278   1        if (++Seg_Pos == 8)
 279   1          Seg_Pos = 0; // 数码管显示专用
 280   1        // 触发跳过
 281   1        if (skip_flag)
 282   1        {
 283   2          // 长按1s
 284   2          time_1s = (++time_1s < 1000) ? time_1s : 1000;
 285   2        }
 286   1        if (++time_500ms == 500)
 287   1        {
 288   2          time_500ms = 0;
 289   2          time_interval_flag = ~time_interval_flag;
 290   2        }
 291   1        if (++time_700ms == 700)
 292   1        {
 293   2          time_700ms = 0;
 294   2          time_set_interval_flag = ~time_set_interval_flag;
 295   2        }
 296   1        if (massage_show_time_flag)
 297   1        {
 298   2          time_1s = (++time_1s < 1000) ? time_1s : 1000;
 299   2          if (time_1s == 1000)
 300   2          {
 301   3            massage_show_flag = 1;
 302   3          }
C51 COMPILER V9.59.0.0   MAIN                                                              01/26/2024 21:15:45 PAGE 6   

 303   2        }
 304   1        Seg_Disp(Seg_Pos, Seg_Buf[Seg_Pos], Seg_Point[Seg_Pos]);
 305   1        Led_Disp(Seg_Pos, ucLed[Seg_Pos]);
 306   1      }
 307          
 308          /* 串口1中断服务函数 */
 309          void Uart1Server() interrupt 4
 310          {
 311   1        if (RI == 1) // 串口接收数据
 312   1        {
 313   2          Uart_Recv[Uart_Recv_Index] = SBUF;
 314   2          Uart_Recv_Index++;
 315   2          RI = 0;
 316   2        }
 317   1      }
 318          void Delay750ms() //@12MHz
 319          {
 320   1        unsigned char i, j, k;
 321   1      
 322   1        _nop_();
 323   1        _nop_();
 324   1        i = 35;
 325   1        j = 51;
 326   1        k = 182;
 327   1        do
 328   1        {
 329   2          do
 330   2          {
 331   3            while (--k)
 332   3              ;
 333   3          } while (--j);
 334   2        } while (--i);
 335   1      }
 336          
 337          /* Main */
 338          void main()
 339          {
 340   1        // 如果有温度读取的话
 341   1        rd_temperature();
 342   1        Delay750ms();
 343   1        Set_Rtc(ucRtc); // 设置初始时间
 344   1        System_Init();
 345   1        Timer0Init();
 346   1        UartInit();
 347   1        while (1)
 348   1        {
 349   2          Key_Proc();
 350   2          Seg_Proc();
 351   2          Led_Proc();
 352   2          Uart_Proc();
 353   2        }
 354   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1091    ----
   CONSTANT SIZE    =     10    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     65      16
   IDATA SIZE       =     16    ----
   BIT SIZE         =      8    ----
C51 COMPILER V9.59.0.0   MAIN                                                              01/26/2024 21:15:45 PAGE 7   

END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
