C51 COMPILER V9.59.0.0   MAIN                                                              01/23/2024 22:15:50 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Driver) DEBUG OBJECTEXTEND PRI
                    -NT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          /* 头文件声明区 */
   2          #include <STC15F2K60S2.H> //单片机寄存器专用头文件
   3          #include <Init.h>     //初始化底层驱动专用头文件
   4          #include <Led.h>      //Led底层驱动专用头文件
   5          #include <Key.h>      //按键底层驱动专用头文件
   6          #include <Seg.h>      //数码管底层驱动专用头文件
   7          #include <stdio.h>      //标准库底层驱动专用头文件
   8          #include <iic.h>      //光敏电阻头文件
   9          #include <ds1302.h>     //ds1302头文件
  10          #include <onewire.h>    //温度传感器头文件
  11          /* 变量声明区 */
  12          unsigned char Key_Val, Key_Down, Key_Old, Key_Up;      // 按键专用变量
  13          unsigned char Key_Slow_Down;                 // 按键减速专用变量
  14          unsigned char Seg_Buf[8] = {10, 10, 10, 10, 10, 10, 10, 10}; // 数码管显示数据存放数组
  15          unsigned char Seg_Point[8] = {0, 0, 0, 0, 0, 0, 0, 0};     // 数码管小数点数据存放数组
  16          unsigned char Seg_Pos;                     // 数码管扫描专用变量
  17          unsigned int Seg_Slow_Down;                  // 数码管减速专用变量
  18          unsigned char ucLed[8] = {0, 0, 0, 0, 0, 0, 0, 0};       // Led显示数据存放数组
  19          
  20          /*时间模块*/
  21          unsigned char time_100ms;          // 100ms计时
  22          unsigned int time_1s;            // 1s计时
  23          unsigned int time_2s;            // 2s计时
  24          unsigned int time_3s;            // 3s计时
  25          unsigned char ucRtc[3] = {0x15, 0x55, 0x55}; // 初始时间为11:11:11
  26          
  27          /*数码管显示模块*/
  28          unsigned char Seg_show_mode = 0;   // 正常界面显示，0时间，1温度回显，2参数，100温湿度
  29          unsigned char old_Seg_show_mode = 0; // 上一次的界面显示
  30          unsigned char re_Seg_show_mode = 0;  // 回显界面显示，0温度回显，1湿度回显，2时间回显
  31          
  32          /*温度处理模块*/
  33          idata float aver_temperature = 0;    // 平均温度
  34          idata unsigned char max_temperature = 0; // 最高温度（这里因为我们只需要显示整数）
  35          idata float old_tempture = 0;      // 旧温度
  36          bit up_tempture_flag = 0;        // 温度是否上升
  37          
  38          /*湿度处理模块*/
  39          idata float aver_humidity = 0;         // 平均湿度
  40          idata unsigned char max_humidity = 0;    // 最高湿度（这里因为我们只需要显示整数）
  41          idata unsigned int count_f = 0;        // 溢出计数
  42          idata unsigned int data_f = 0;         // 1s的频率
  43          bit humidity_flag = 1;             // 是否有效记录
  44          idata unsigned char demo_temperature = 30; // 温度参考
  45          idata float old_humidity = 0;        // 旧湿度
  46          bit up_humidity_flag = 0;          // 湿度是否上升
  47          
  48          /*触发和光照模块*/
  49          unsigned char trigger_number = 0;      // 触发次数
  50          unsigned char old_light = 0;         // 旧的光照值
  51          unsigned char trigger_time[3] = {0, 0, 0}; // 最后一次采集时间
  52          bit light_down_flag = 0;           // 光照是否变暗
  53          
  54          /* 键盘处理函数 */
C51 COMPILER V9.59.0.0   MAIN                                                              01/23/2024 22:15:50 PAGE 2   

  55          void Key_Proc()
  56          {
  57   1        if (Key_Slow_Down)
  58   1          return;
  59   1        Key_Slow_Down = 1; // 键盘减速程序
  60   1      
  61   1        Key_Val = Key_Read();           // 实时读取键码值
  62   1        Key_Down = Key_Val & (Key_Old ^ Key_Val); // 捕捉按键下降沿
  63   1        Key_Up = ~Key_Val & (Key_Old ^ Key_Val);  // 捕捉按键上降沿
  64   1        Key_Old = Key_Val;              // 辅助扫描变量
  65   1        // 按下界面切换的按键
  66   1        if (Key_Down == 4)
  67   1        {
  68   2          Seg_show_mode++;
  69   2          if (Seg_show_mode > 2)
  70   2          {
  71   3            Seg_show_mode = 0; // 进行循环
  72   3          }
  73   2        }
  74   1        // 按下回显界面切换的按键，并且处于回显界面
  75   1        if (Key_Down == 5 && Seg_show_mode == 1)
  76   1        {
  77   2          re_Seg_show_mode++;
  78   2          if (re_Seg_show_mode > 2)
  79   2          {
  80   3            re_Seg_show_mode = 0; // 进行循环
  81   3          }
  82   2        }
  83   1        if (Key_Down == 8 && Seg_show_mode == 2)
  84   1        {
  85   2          if (++demo_temperature > 100)
  86   2          {
  87   3            demo_temperature = 0;
  88   3          }
  89   2        }
  90   1        if (Key_Down == 9 && Seg_show_mode == 2)
  91   1        {
  92   2          if (--demo_temperature < 0)
  93   2          {
  94   3            demo_temperature = 99;
  95   3          }
  96   2        }
  97   1        if (Key_Down == 9 && Seg_show_mode == 1 && re_Seg_show_mode == 2)
  98   1        {
  99   2          if (++time_2s == 200)
 100   2          {
 101   3            // 现在长按了2s，清空全部的数据
 102   3            trigger_number = 0;
 103   3            aver_temperature = 0;
 104   3            max_temperature = 0;
 105   3            old_tempture = 0;
 106   3      
 107   3            aver_humidity = 0;
 108   3            max_humidity = 0;
 109   3            old_humidity = 0;
 110   3            trigger_time[0] = 0;
 111   3            trigger_time[1] = 0;
 112   3            trigger_time[2] = 0;
 113   3          }
 114   2        }
 115   1        else
 116   1        {
C51 COMPILER V9.59.0.0   MAIN                                                              01/23/2024 22:15:50 PAGE 3   

 117   2          time_2s = 0;
 118   2        }
 119   1      }
 120          
 121          /* 信息处理函数 */
 122          void Seg_Proc()
 123          {
 124   1        if (Seg_Slow_Down)
 125   1          return;
 126   1        Seg_Slow_Down = 1; // 数码管减速程序
 127   1        if (Seg_show_mode == 0)
 128   1        {
 129   2          re_Seg_show_mode = 0;
 130   2          // 显示时间
 131   2          Read_Rtc(ucRtc);
 132   2          Seg_Buf[0] = ucRtc[0] / 16;
 133   2          Seg_Buf[1] = ucRtc[0] % 16;
 134   2          Seg_Buf[3] = ucRtc[1] / 16;
 135   2          Seg_Buf[4] = ucRtc[1] % 16;
 136   2          Seg_Buf[6] = ucRtc[2] / 16;
 137   2          Seg_Buf[7] = ucRtc[2] % 16;
 138   2          Seg_Buf[2] = Seg_Buf[5] = 16; //-
 139   2          Seg_Point[6] = 0;
 140   2        }
 141   1        else if (Seg_show_mode == 1)
 142   1        {
 143   2          // 进入回显界面，且默认为温度
 144   2          switch (re_Seg_show_mode)
 145   2          {
 146   3          case 0:        // 温度回显
 147   3            Seg_Buf[0] = 11; // C
 148   3            if (trigger_number == 0)
 149   3            {
 150   4              Seg_Buf[1] = Seg_Buf[2] = Seg_Buf[3] = Seg_Buf[4] = Seg_Buf[5] = Seg_Buf[6] = Seg_Buf[7] = 10; // 灭
 151   4              Seg_Point[6] = 0;
 152   4            }
 153   3            else
 154   3            {
 155   4              unsigned int temp;
 156   4              temp = aver_temperature * 10;
 157   4              Seg_Buf[1] = 10; // 灭
 158   4              Seg_Buf[2] = max_temperature / 10;
 159   4              Seg_Buf[3] = max_temperature % 10;
 160   4              Seg_Buf[4] = 16; //-
 161   4              Seg_Buf[5] = temp / 100;
 162   4              Seg_Buf[6] = (temp % 100) / 10;
 163   4              Seg_Buf[7] = temp % 10;
 164   4              Seg_Point[6] = 1;
 165   4            }
 166   3            break;
 167   3          case 1:        // 湿度回显
 168   3            Seg_Buf[0] = 12; // H
 169   3            if (trigger_number == 0)
 170   3            {
 171   4              Seg_Buf[1] = Seg_Buf[2] = Seg_Buf[3] = Seg_Buf[4] = Seg_Buf[5] = Seg_Buf[6] = Seg_Buf[7] = 10; // 灭
 172   4              Seg_Point[6] = 0;
 173   4            }
 174   3            else
 175   3            {
 176   4              unsigned int temp;
 177   4              temp = aver_humidity * 10;
 178   4              Seg_Buf[1] = 10; // 灭
C51 COMPILER V9.59.0.0   MAIN                                                              01/23/2024 22:15:50 PAGE 4   

 179   4              Seg_Buf[2] = max_humidity / 10;
 180   4              Seg_Buf[3] = max_humidity % 10;
 181   4              Seg_Buf[4] = 16; //-
 182   4              Seg_Buf[5] = temp / 100;
 183   4              Seg_Buf[6] = (temp % 100) / 10;
 184   4              Seg_Buf[7] = temp % 10;
 185   4              Seg_Point[6] = 1;
 186   4            }
 187   3            break;
 188   3          case 2:        // 时间回显
 189   3            Seg_Buf[0] = 13; // F
 190   3            if (trigger_number == 0)
 191   3            {
 192   4              Seg_Buf[1] = Seg_Buf[2] = 0;
 193   4              Seg_Buf[3] = Seg_Buf[4] = Seg_Buf[5] = Seg_Buf[6] = Seg_Buf[7] = 16; // 灭
 194   4              Seg_Point[6] = 0;
 195   4            }
 196   3            else
 197   3            {
 198   4              Seg_Buf[1] = trigger_number / 10;
 199   4              Seg_Buf[2] = trigger_number % 10;
 200   4              Seg_Buf[3] = trigger_time[0] / 16;
 201   4              Seg_Buf[4] = trigger_time[0] % 16;
 202   4              Seg_Buf[5] = 16; //-
 203   4              Seg_Buf[6] = trigger_time[1] / 16;
 204   4              Seg_Buf[7] = trigger_time[1] % 16;
 205   4              Seg_Point[6] = 0;
 206   4            }
 207   3            break;
 208   3          }
 209   2        }
 210   1        else if (Seg_show_mode == 2)
 211   1        {
 212   2          // 显示参数
 213   2          Seg_Buf[0] = 14; // P
 214   2      
 215   2          Seg_Buf[1] = Seg_Buf[2] = Seg_Buf[3] = Seg_Buf[4] = Seg_Buf[5] = 10; // 灭
 216   2          Seg_Buf[6] = demo_temperature / 10;
 217   2          Seg_Buf[7] = demo_temperature % 10;
 218   2          Seg_Point[6] = 0;
 219   2          re_Seg_show_mode = 0;
 220   2        }
 221   1        else if (Seg_show_mode == 100)
 222   1        {
 223   2          unsigned char temp_temperature;
 224   2          unsigned char temp_humidity;
 225   2          // 显示温湿度界面
 226   2          Seg_Buf[0] = 15; // E
 227   2          temp_temperature = old_tempture;
 228   2          temp_humidity = old_humidity;
 229   2          Seg_Buf[1] = Seg_Buf[2] = 10; // 灭
 230   2          Seg_Buf[3] = temp_temperature / 10;
 231   2          Seg_Buf[4] = temp_temperature % 10;
 232   2          Seg_Buf[5] = 16; //-
 233   2          Seg_Buf[6] = temp_humidity / 10;
 234   2          Seg_Buf[7] = temp_humidity % 10;
 235   2          Seg_Point[6] = 0;
 236   2        }
 237   1      }
 238          
 239          /* 其他显示函数 */
 240          void Led_Proc()
C51 COMPILER V9.59.0.0   MAIN                                                              01/23/2024 22:15:50 PAGE 5   

 241          {
 242   1        if (Seg_show_mode == 0)
 243   1        {
 244   2          ucLed[0] = 1;
 245   2        }
 246   1        else
 247   1        {
 248   2          ucLed[0] = 0;
 249   2        }
 250   1        if (Seg_show_mode == 1)
 251   1        {
 252   2          ucLed[1] = 1;
 253   2        }
 254   1        else
 255   1        {
 256   2          ucLed[1] = 0;
 257   2        }
 258   1        if (Seg_show_mode == 100)
 259   1        {
 260   2          ucLed[2] = 1;
 261   2        }
 262   1        else
 263   1        {
 264   2          ucLed[2] = 0;
 265   2        }
 266   1        // 采集湿度无效
 267   1        if (!humidity_flag)
 268   1        {
 269   2          ucLed[4] = 1;
 270   2        }
 271   1        else
 272   1        {
 273   2          ucLed[4] = 0;
 274   2        }
 275   1        if (up_humidity_flag && up_tempture_flag && (trigger_number > 2))
 276   1        {
 277   2          ucLed[5] = 1;
 278   2        }
 279   1        else
 280   1        {
 281   2          ucLed[5] = 0;
 282   2        }
 283   1      }
 284          /* 定时器0中断初始化函数 */
 285          void Timer0Init(void) // 1毫秒@12.000MHz
 286          {
 287   1        AUXR &= 0x7F; // 定时器时钟12T模式
 288   1        TMOD &= 0xF0; // 设置定时器模式
 289   1        TL0 = 0x18;   // 设置定时初始值
 290   1        TH0 = 0xFC;   // 设置定时初始值
 291   1        TF0 = 0;    // 清除TF0标志
 292   1        TR0 = 1;    // 定时器0开始计时
 293   1        ET0 = 1;    // 定时器中断0打开
 294   1        EA = 1;     // 总中断打开
 295   1      }
 296          /*计数器1终端初始化函数*/
 297          void Timer1Init(void) // 1微秒@12.000MHz
 298          {
 299   1        AUXR &= 0xBF; // 定时器时钟12T模式
 300   1        TMOD &= 0x0F; // 设置定时器模式
 301   1        TMOD |= 0x20; // 设置定时器模式
 302   1        TL1 = 0xFF;   // 设置定时初值
C51 COMPILER V9.59.0.0   MAIN                                                              01/23/2024 22:15:50 PAGE 6   

 303   1        TH1 = 0xFF;   // 设置定时重载值
 304   1        TF1 = 0;    // 清除TF1标志
 305   1        TR1 = 1;    // 定时器1开始计时
 306   1        ET1 = 1;    // 定时器1中断打开
 307   1        EA = 1;     // 总中断打开
 308   1      }
 309          /* 计数器1中断服务函数 */
 310          void Timer1Server() interrupt 3
 311          {
 312   1        count_f++;
 313   1      }
 314          /* 定时器0中断服务函数 */
 315          void Timer0Server() interrupt 1
 316          {
 317   1        if (++Key_Slow_Down == 10)
 318   1          Key_Slow_Down = 0; // 键盘减速专用
 319   1        if (++Seg_Slow_Down == 200)
 320   1          Seg_Slow_Down = 0; // 数码管减速专用
 321   1        if (++Seg_Pos == 8)
 322   1          Seg_Pos = 0; // 数码管显示专用
 323   1        // 1s的时候，我们将溢出的计数进行取出
 324   1        if (++time_1s == 1000)
 325   1        {
 326   2          data_f = count_f;
 327   2          count_f = 0;
 328   2        }
 329   1        // 当我们触发了光暗的时候
 330   1        if (light_down_flag)
 331   1        {
 332   2          // 采集3s
 333   2          if (++time_3s == 3000)
 334   2          {
 335   3            light_down_flag = 0;
 336   3            Seg_show_mode = old_Seg_show_mode; // 回到原本的显示
 337   3          }
 338   2          // 0.1s取反
 339   2          if (++time_100ms == 100)
 340   2          {
 341   3            ucLed[3] = ~ucLed[3];
 342   3          }
 343   2        }
 344   1      
 345   1        Seg_Disp(Seg_Pos, Seg_Buf[Seg_Pos], Seg_Point[Seg_Pos]);
 346   1        Led_Disp(Seg_Pos, ucLed[Seg_Pos]);
 347   1      }
 348          void get_temperature()
 349          {
 350   1        float temp_temperature;
 351   1        temp_temperature = rd_temperature();
 352   1        if (trigger_number > 2 && temp_temperature > old_tempture)
 353   1        {
 354   2          up_tempture_flag = 1;
 355   2        }
 356   1        else
 357   1        {
 358   2          up_tempture_flag = 0;
 359   2        }
 360   1        if (max_temperature < temp_temperature)
 361   1        {
 362   2          max_temperature = temp_temperature;
 363   2        }
 364   1        aver_temperature = (aver_temperature * (trigger_number - 1) + temp_temperature) / trigger_number;
C51 COMPILER V9.59.0.0   MAIN                                                              01/23/2024 22:15:50 PAGE 7   

 365   1        old_tempture = temp_temperature;
 366   1      }
 367          void get_humidity()
 368          {
 369   1        // 这个时候认为是无效记录
 370   1        if (data_f < 200 || data_f > 2000)
 371   1        {
 372   2          humidity_flag = 0;
 373   2        }
 374   1        else
 375   1        {
 376   2          float temp_humidity;
 377   2          // 采集有效
 378   2          humidity_flag = 1;
 379   2          temp_humidity = (data_f - 200) * 2 / 45 + 10;
 380   2          if (trigger_number > 2 && temp_humidity > old_humidity)
 381   2          {
 382   3            // 湿度升高
 383   3            up_humidity_flag = 1;
 384   3          }
 385   2          else
 386   2          {
 387   3            up_humidity_flag = 0;
 388   3          }
 389   2          if (max_humidity < temp_humidity)
 390   2          {
 391   3            max_humidity = temp_humidity;
 392   3          }
 393   2          aver_humidity = (aver_humidity * (trigger_number - 1) + temp_humidity) / trigger_number;
 394   2          old_humidity = temp_humidity;
 395   2        }
 396   1      }
 397          void get_light()
 398          {
 399   1        unsigned char temp_light;
 400   1        temp_light = Ad_Read(0x01);
 401   1        // 这里自行考虑变暗的阈值
 402   1        // 当从亮变暗，并且之前没有进行变化的时候
 403   1        if (old_light > 120 && temp_light < 80 && !light_down_flag)
 404   1        {
 405   2          light_down_flag = 1;
 406   2          trigger_number++;
 407   2          get_temperature();
 408   2          get_humidity();
 409   2          Read_Rtc(trigger_time);        // 记录一下采集的时间
 410   2          old_Seg_show_mode = Seg_show_mode; // 记录一下跳转前的状态
 411   2          Seg_show_mode = 100;         // 跳转到温湿度显示界面
 412   2        }
 413   1        old_light = temp_light;
 414   1      }
 415          /* Main */
 416          void main()
 417          {
 418   1        System_Init();
 419   1        Timer0Init();
 420   1        Timer1Init();
 421   1        Set_Rtc(ucRtc);
 422   1        while (1)
 423   1        {
 424   2          Key_Proc();
 425   2          Seg_Proc();
 426   2          Led_Proc();
C51 COMPILER V9.59.0.0   MAIN                                                              01/23/2024 22:15:50 PAGE 8   

 427   2          get_light();
 428   2        }
 429   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1550    ----
   CONSTANT SIZE    =   ----    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     50      11
   IDATA SIZE       =     23    ----
   BIT SIZE         =      4    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
