C51 COMPILER V9.59.0.0   MAIN                                                              02/06/2024 23:16:25 PAGE 1   


C51 COMPILER V9.59.0.0, COMPILATION OF MODULE MAIN
OBJECT MODULE PLACED IN .\Objects\main.obj
COMPILER INVOKED BY: D:\Keil_v5\C51\BIN\C51.EXE main.c OPTIMIZE(8,SPEED) BROWSE INCDIR(..\Driver) DEBUG OBJECTEXTEND PRI
                    -NT(.\Listings\main.lst) TABS(2) OBJECT(.\Objects\main.obj)

line level    source

   1          #include "main.h"
   2          /* 变量声明区 */
   3          uchar Key_Slow_Down;                 // 按键减速专用变量
   4          uchar Seg_Buf[8] = {10, 10, 10, 10, 10, 10, 10, 10}; // 数码管显示数据存放数组
   5          uchar Seg_Point[8] = {0, 0, 0, 0, 0, 0, 0, 0};     // 数码管小数点数据存放数组
   6          uchar Seg_Pos;                     // 数码管扫描专用变量
   7          uint Seg_Slow_Down;                  // 数码管减速专用变量
   8          uchar ucLed[8] = {0, 0, 0, 0, 0, 0, 0, 0};       // Led显示数据存放数组
   9          uchar Uart_Slow_Down;                // 串口减速专用变量
  10          uchar Uart_Recv[10];                 // 串口接收数据储存数组 默认10个字节 若接收数据较长 可更改最大字节数
  11          uchar Uart_Recv_Index;                 // 串口接收数组指针
  12          /*时间*/
  13          uint time_1s_reset;
  14          uint time_1s_DAC;
  15          bit reset_count_flag;
  16          bit DAC_change_flag;
  17          bit DAC_out_mode;
  18          
  19          /* 界面切换 */
  20          bit Seg_show_mode;    // 0数据界面 1参数界面
  21          uchar data_show_mode; // 0温度数据 1距离数据 2变更次数
  22          bit para_show_mode;   // 0温度参数 1距离参数
  23          
  24          /* 数据记录 */
  25          uint temperature_100x;  // 100倍的温度数据
  26          uchar dis_value;    // 距离数据
  27          uint change_count;    // 变更次数
  28          uchar temperature_demo; // 温度参数
  29          uchar dis_demo;     // 距离参数
  30          void init_Seg()
  31          {
  32   1        uchar i;
  33   1        for (i = 0; i < 8; i++)
  34   1        {
  35   2          Seg_Buf[i] = 10;  // 数码管显示数据初始化
  36   2          Seg_Point[i] = 0; // 数码管小数点数据初始化
  37   2        }
  38   1      }
  39          /* 键盘处理函数 */
  40          void Key_Proc()
  41          {
  42   1        static uchar Key_Val, Key_Down, Key_Old, Key_Up; // 按键专用变量
  43   1        if (Key_Slow_Down)
  44   1          return;
  45   1        Key_Slow_Down = 1; // 键盘减速程序
  46   1      
  47   1        Key_Val = Key_Read();           // 实时读取键码值
  48   1        Key_Down = Key_Val & (Key_Old ^ Key_Val); // 捕捉按键下降沿
  49   1        Key_Up = ~Key_Val & (Key_Old ^ Key_Val);  // 捕捉按键上降沿
  50   1        Key_Old = Key_Val;              // 辅助扫描变量
  51   1        if (Key_Down == 13)
  52   1          reset_count_flag = 1;
  53   1        if (Key_Up == 13)
  54   1        {
C51 COMPILER V9.59.0.0   MAIN                                                              02/06/2024 23:16:25 PAGE 2   

  55   2          if (time_1s_reset >= 1000)
  56   2          {
  57   3            change_count = 0;
  58   3            EEPROM_Write(&change_count, 0, 1);
*** WARNING C182 IN LINE 58 OF main.c: pointer to different objects
  59   3          }
  60   2          else
  61   2          {
  62   3            init_Seg();
  63   3            if (Seg_show_mode)
  64   3            {
  65   4              change_count++;
  66   4              EEPROM_Write(&change_count, 0, 1);
*** WARNING C182 IN LINE 66 OF main.c: pointer to different objects
  67   4            }
  68   3            Seg_show_mode ^= 1;
  69   3            data_show_mode = para_show_mode = 0;
  70   3          }
  71   2          reset_count_flag = time_1s_reset = 0;
  72   2        }
  73   1        if (Key_Down == 12)
  74   1        {
  75   2          DAC_change_flag = 1;
  76   2        }
  77   1        if (Key_Up == 12)
  78   1        {
  79   2          if (time_1s_DAC >= 1000)
  80   2            DAC_out_mode ^= 1;
  81   2          else
  82   2          {
  83   3            if (Seg_show_mode)
  84   3              /* 参数界面*/
  85   3              para_show_mode ^= 1;
  86   3            else
  87   3            {
  88   4              /* 数据界面*/
  89   4              init_Seg();
  90   4              data_show_mode = (++data_show_mode) % 3;
  91   4            }
  92   3          }
  93   2        }
  94   1        if (Seg_show_mode)
  95   1        {
  96   2          if (para_show_mode)
  97   2          {
  98   3            /* 距离参数 */
  99   3            if (Key_Down == 16)
 100   3              dis_demo = (dis_demo - 5 < 0) ? 0 : (dis_demo - 5);
 101   3            if (Key_Down == 17)
 102   3              dis_demo = (dis_demo + 5 > 99) ? 99 : (dis_demo + 5);
 103   3          }
 104   2          else
 105   2          {
 106   3            /* 温度参数 */
 107   3            if (Key_Down == 16)
 108   3              temperature_demo = (temperature_demo - 2 < 0) ? 0 : (temperature_demo - 2);
 109   3            if (Key_Down == 17)
 110   3              temperature_demo = (temperature_demo + 2 > 99) ? 99 : (temperature_demo + 2);
 111   3          }
 112   2        }
 113   1      }
 114          
C51 COMPILER V9.59.0.0   MAIN                                                              02/06/2024 23:16:25 PAGE 3   

 115          /* 信息处理函数 */
 116          void Seg_Proc()
 117          {
 118   1        uchar i;
 119   1        if (Seg_Slow_Down)
 120   1          return;
 121   1        Seg_Slow_Down = 1; // 数码管减速程序
 122   1        temperature_100x = rd_temperature() * 100;
 123   1        dis_value = Ut_Wave_Data();
 124   1        if (Seg_show_mode)
 125   1        {
 126   2          /* 参数界面 */
 127   2          switch (data_show_mode)
 128   2          {
 129   3          case 0:
 130   3            /* 温度数据 */
 131   3            Seg_Buf[0] = 11; // C
 132   3            Seg_Buf[4] = temperature_100x / 1000 % 10;
 133   3            Seg_Buf[5] = temperature_100x / 100 % 10;
 134   3            Seg_Buf[6] = temperature_100x / 10 % 10;
 135   3            Seg_Buf[7] = temperature_100x % 10;
 136   3            Seg_Point[5] = 1;
 137   3            break;
 138   3          case 1:
 139   3            /* 距离数据 */
 140   3            Seg_Buf[0] = 12; // L
 141   3            Seg_Buf[6] = dis_value / 10 % 10;
 142   3            Seg_Buf[7] = dis_value % 10;
 143   3            break;
 144   3          case 2:
 145   3            /* 变更次数 */
 146   3            Seg_Buf[0] = 13; // N
 147   3            Seg_Buf[3] = change_count / 10000 % 10;
 148   3            Seg_Buf[4] = change_count / 1000 % 10;
 149   3            Seg_Buf[5] = change_count / 100 % 10;
 150   3            Seg_Buf[6] = change_count / 10 % 10;
 151   3            Seg_Buf[7] = change_count % 10;
 152   3            for (i = 3; i < 6; i++)
 153   3            {
 154   4              if (Seg_Buf[i] != 0)
 155   4                break;
 156   4              Seg_Buf[i] = 10;
 157   4            }
 158   3      
 159   3            break;
 160   3          }
 161   2        }
 162   1        else
 163   1        {
 164   2          /* 数据界面 */
 165   2          Seg_Buf[0] = 14; // P
 166   2          Seg_Buf[3] = (uchar)para_show_mode + 1;
 167   2          if (para_show_mode)
 168   2          {
 169   3            /* 距离参数 */
 170   3            Seg_Buf[6] = dis_demo / 10; // 十位
 171   3            Seg_Buf[7] = dis_demo % 10; // 个位
 172   3          }
 173   2          else
 174   2          {
 175   3            /* 温度参数 */
 176   3            Seg_Buf[6] = temperature_demo / 10; // 十位
C51 COMPILER V9.59.0.0   MAIN                                                              02/06/2024 23:16:25 PAGE 4   

 177   3            Seg_Buf[7] = temperature_demo % 10; // 个位
 178   3          }
 179   2        }
 180   1      }
 181          
 182          /* 其他显示函数 */
 183          void Led_Proc()
 184          {
 185   1        if (DAC_out_mode)
 186   1        {
 187   2          if (dis_value <= dis_demo)
 188   2            Da_Write(102); // 2*51
 189   2          else
 190   2            Da_Write(204); // 4*51
 191   2        }
 192   1        else
 193   1          Da_Write(20); // 0.4*51
 194   1        ucLed[0] = (temperature_100x / 100.0 >= temperature_demo);
 195   1        ucLed[1] = (dis_value < dis_demo);
 196   1        ucLed[2] = DAC_out_mode;
 197   1      }
 198          /* 串口处理函数 */
 199          void Uart_Proc()
 200          {
 201   1        if (Uart_Slow_Down)
 202   1          return;
 203   1        Uart_Slow_Down = 1; // 串口减速程序
 204   1        // 当有数据输入的时候
 205   1        if (Uart_Recv[0] != NULL)
 206   1        {
 207   2          if (Uart_Recv[0] == 'S' && Uart_Recv[1] == 'T' && Uart_Recv[2] == '\r' && Uart_Recv[3] == '\n')
 208   2            printf("$%d,%0.2f\r\n", (uint)dis_value, (float)temperature_100x / 100.0);
 209   2          else if (Uart_Recv[0] == 'P' && Uart_Recv[1] == 'A' && Uart_Recv[2] == 'R' && Uart_Recv[3] == 'A' &&
 210   2               Uart_Recv[4] == '\r' && Uart_Recv[5] == '\n')
 211   2            printf("#%d,%d\r\n", dis_demo, temperature_demo);
 212   2          else
 213   2            printf("error\r\n");
 214   2          memset(Uart_Recv, 0, sizeof(Uart_Recv));
 215   2          Uart_Recv_Index = 0;
 216   2        }
 217   1      }
 218          
 219          /* 定时器0中断初始化函数 */
 220          void Timer0Init(void) // 1毫秒@12.000MHz
 221          {
 222   1        AUXR &= 0x7F; // 定时器时钟12T模式
 223   1        TMOD &= 0xF0; // 设置定时器模式
 224   1        TL0 = 0x18;   // 设置定时初始值
 225   1        TH0 = 0xFC;   // 设置定时初始值
 226   1        TF0 = 0;    // 清除TF0标志
 227   1        TR0 = 1;    // 定时器0开始计时
 228   1        ET0 = 1;    // 定时器中断0打开
 229   1        EA = 1;     // 总中断打开
 230   1      }
 231          
 232          /* 定时器0中断服务函数 */
 233          void Timer0Server() interrupt 1
 234          {
 235   1        if (++Key_Slow_Down == 10)
 236   1          Key_Slow_Down = 0; // 键盘减速专用
 237   1        if (++Seg_Slow_Down == 500)
 238   1          Seg_Slow_Down = 0; // 数码管减速专用
C51 COMPILER V9.59.0.0   MAIN                                                              02/06/2024 23:16:25 PAGE 5   

 239   1        if (++Uart_Slow_Down == 200)
 240   1          Uart_Slow_Down = 0; // 串口减速专用
 241   1        if (++Seg_Pos == 8)
 242   1          Seg_Pos = 0; // 数码管显示专用
 243   1        if (reset_count_flag)
 244   1        {
 245   2          if (++time_1s_reset >= 1000)
 246   2            time_1s_reset = 1000;
 247   2        }
 248   1        else
 249   1        {
 250   2          time_1s_reset = 0;
 251   2        }
 252   1        if (DAC_change_flag)
 253   1        {
 254   2          if (++time_1s_DAC >= 1000)
 255   2            time_1s_DAC = 1000;
 256   2        }
 257   1        else
 258   1        {
 259   2          time_1s_DAC = 0;
 260   2        }
 261   1        Seg_Disp(Seg_Pos, Seg_Buf[Seg_Pos], Seg_Point[Seg_Pos]);
 262   1        Led_Disp(Seg_Pos, ucLed[Seg_Pos]);
 263   1      }
 264          
 265          /* 串口1中断服务函数 */
 266          void Uart1Server() interrupt 4
 267          {
 268   1        if (RI == 1) // 串口接收数据
 269   1        {
 270   2          Uart_Recv[Uart_Recv_Index] = SBUF;
 271   2          Uart_Recv_Index++;
 272   2          RI = 0;
 273   2        }
 274   1      }
 275          void Delay750ms() //@12MHz
 276          {
 277   1        unsigned char i, j, k;
 278   1      
 279   1        _nop_();
 280   1        _nop_();
 281   1        i = 35;
 282   1        j = 51;
 283   1        k = 182;
 284   1        do
 285   1        {
 286   2          do
 287   2          {
 288   3            while (--k)
 289   3              ;
 290   3          } while (--j);
 291   2        } while (--i);
 292   1      }
 293          
 294          /* Main */
 295          void main()
 296          {
 297   1        // 如果有温度读取的话
 298   1        rd_temperature();
 299   1        Delay750ms();
 300   1      
C51 COMPILER V9.59.0.0   MAIN                                                              02/06/2024 23:16:25 PAGE 6   

 301   1        System_Init();
 302   1        Timer0Init();
 303   1        Uart1_Init();
 304   1        EEPROM_Read(&change_count, 0, 1);
*** WARNING C182 IN LINE 304 OF main.c: pointer to different objects
 305   1        while (1)
 306   1        {
 307   2          Key_Proc();
 308   2          Seg_Proc();
 309   2          Led_Proc();
 310   2          Uart_Proc();
 311   2        }
 312   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1268    ----
   CONSTANT SIZE    =     29    ----
   XDATA SIZE       =   ----    ----
   PDATA SIZE       =   ----    ----
   DATA SIZE        =     56    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =      5    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  3 WARNING(S),  0 ERROR(S)
